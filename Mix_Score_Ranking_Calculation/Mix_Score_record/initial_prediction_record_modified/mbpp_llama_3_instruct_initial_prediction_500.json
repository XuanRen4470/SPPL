{
    "initial_prediction": [
        "def Pair(a, b):\n    return (a, b)\n\ndef max_chain_length(pairs, n):\n    pairs.sort(key=lambda x: x[1])\n    dp = [1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if pairs[j][1] < pairs[i][0]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)",
        "def first_repeated_char(s): \n    char_count = {} \n    for char in s: \n        if char in char_count: \n            return char \n        else: \n            char_count[char] = 1 \n    return None",
        "def get_ludic(n): \n    lucid_numbers = [] \n    num = 2 \n    while num <= n: \n        is_lucid = True \n        for i in range(2, int(num**0.5) + 1): \n            if num % i == 0: \n                is_lucid = False \n                break \n        if is_lucid: \n            lucid_numbers.append(num) \n        num += 1 \n    return lucid_numbers",
        "split(\" \".join(reversed(input().split())))",
        "def prime_num(n): \n    if n <= 1: \n        return False \n    elif n <= 3: \n        return True \n    elif n % 2 == 0 or n % 3 == 0: \n        return False \n    i = 5 \n    while i * i <= n: \n        if n % i == 0 or n % (i + 2) == 0: \n            return False \n        i += 6 \n    return True",
        "import math\n\ndef radian_degree(deg):\n    return deg * math.pi / 180",
        "import re\n\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return match.group(), match.start(), match.end()\n    else:\n        return None",
        "def bell_Number(n): \n    if n < 1: \n        return 0 \n    elif n == 1: \n        return 1 \n    else: \n        a, b = 1, 1 \n        for _ in range(2, n): \n            a, b = b, a + b \n        return b",
        "def floor_Min(a, b, c): \n    return (a + b + c) // 3",
        "def remove_kth_element(lst,k): \n    if k > len(lst): \n        return \"k is greater than the length of the list\" \n    else: \n        return lst[:k-1] + lst[k:]",
        "max_of_nth = lambda lst, n: max(x[n] for x in lst)",
        "def merge(lists): \n    result = []\n    for i in range(len(lists)):\n        result.append(lists[i][0])\n        result.append(lists[i][-1])\n    return [result[i:i+3] for i in range(0, len(result), 3)]",
        "max_value = max((key, max(record)) for key, record in record_list)",
        "sum(sum(t) for t in [(1, 3), (5, 6, 7), (2, 6)])",
        "def average_tuple(tuples):\n    result = []\n    for tup in tuples:\n        result.append(sum(tup) / len(tup))\n    return result",
        "def tuple_modulo(t1, t2):\n    return tuple(i % j for i, j in zip(t1, t2))",
        "def min_Jumps(d, p, n):\n    if d == 0:\n        return 0\n    if p == 0:\n        return n\n    if n == 0:\n        return float('inf')\n    if d <= p:\n        return 1 + min_Jumps(0, p-d, n-1)\n    else:\n        return 1 + min_Jumps(d-p, p, n-1)",
        "div_list = lambda l1, l2: list(map(lambda x, y: x/y, l1, l2))",
        "def move_num(s): \n    result = '' \n    is_num = False \n    for char in s: \n        if char.isdigit(): \n            if not is_num: \n                result += '0' \n            result += char \n            is_num = True \n        else: \n            if is_num: \n                result += '0' \n            result += char \n            is_num = False \n    return result",
        "def largest_subset(nums, k):\n    nums.sort()\n    subset = [nums[0]]\n    for num in nums[1:]:\n        if num % subset[-1][1] == 0:\n            subset.append([num, subset[-1][1]])\n        else:\n            subset.append([num, num])\n    return max(subset, key=lambda x: x[0])[0] // k * k",
        "def increment_numerics(lst, k):\n    return [str(int(x) + k) if x.isdigit() else x for x in lst]",
        "sorted_list = sorted(list1 + list2)\nlength = len(sorted_list)\nif length % 2 == 0:\n    median = (sorted_list[length // 2 - 1] + sorted_list[length // 2]) / 2\nelse:\n    median = sorted_list[length // 2]",
        "map(lambda x: x**2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])",
        "def is_upper(s): \n    return s.upper()",
        "def swap_List(lst): \n    if len(lst) > 1: \n        lst[0], lst[-1] = lst[-1], lst[0] \n    return lst",
        "radius = 1\nreturn 0.5 * radius ** 2",
        "def find_First_Missing(arr, start, end): \n    for i in range(start, end + 1): \n        if i not in arr: \n            return i",
        "replace_spaces = lambda s: s.replace(' ', '%20')",
        "def Split(lst):\n    return [i for i in lst if i % 2 == 0]",
        "def get_coordinates(coord): \n    x, y = coord \n    return [[x-1, y-1], [x-1, y], [x-1, y+1], [x, y-1], [x, y+1], [x+1, y-1], [x+1, y], [x+1, y+1]]",
        "import re\n\ndef replace_spaces(s):\n    s = re.sub(' ', '_', s)\n    s = re.sub('_','', s)\n    return s",
        "def move_zero([1,0,2,0,3,4]): \n    while 0 in [1,0,2,0,3,4]: \n        [1,0,2,0,3,4].remove(0) \n    return [1,2,3,4,0,0]",
        "def pair_OR_Sum(arr,n):\n    result = 0\n    for i in range(len(arr)):\n        for j in range(i+1,len(arr)):\n            result += arr[i]^arr[j]\n    return result",
        "sum(x*x*x*x for x in range(2, 3+1, 2))",
        "import heapq\n\ndef heap_sort(nums):\n    heapq.heapify(nums)\n    result = []\n    while nums:\n        result.append(heapq.heappop(nums))\n    return result",
        "def Check_Solution(a, b, c):\n    D = b**2 - 4*a*c\n    r1 = (-b + D**0.5) / (2*a)\n    r2 = (-b - D**0.5) / (2*a)\n    if r1*r2 == 1:\n        return \"Yes\"\n    else:\n        return \"No\"",
        "def noprofit_noloss(amount, cost):\n    return cost <= 0 or amount <= cost",
        "def wind_chill(temperature, wind_speed):\n    if temperature < 50 and wind_speed > 2:\n        return 35.74 + 0.6215*temperature - 35.75*wind_speed**0.16 + 0.4275*temperature*wind_speed**0.16\n    else:\n        return temperature",
        "def sample_nam(names):\n    return sum(len(name) for name in names if name[0].isupper())",
        "def remove_parenthesis(s): \n    return s[0:s.index('(')].strip() + s[s.index(')')+1:].strip()",
        "def is_nonagonal(n):\n    return int(((9*n**2)-9*n)/2)",
        "def remove_similar_row(matrix):\n    seen = set()\n    result = []\n    for row in matrix:\n        row_tuple = tuple(sorted(row))\n        if row_tuple not in seen:\n            seen.add(row_tuple)\n            result.append(row)\n    return tuple(result)",
        "def text_match_wordz_middle(text): \n    if 'z' in text and not text[0].lower() == 'z' and not text[-1].lower() == 'z':\n        return 'Found a match!'\n    else:\n        return 'No match found'",
        "def reverse_Array_Upto_K(arr,k): \n    return arr[:k][::-1] + arr[k:]",
        "def find_k_product(tuples, k): \n    result = 1 \n    for t in tuples: \n        result *= t[k-1] \n    return result",
        "n = int(input())\nk = int(input())\nprint(n**3 // k**3)",
        "def split_upperstring(s): \n    result = [] \n    temp = '' \n    for char in s: \n        if char.isupper(): \n            if temp: \n                result.append(temp) \n                temp = '' \n        else: \n            temp += char \n    if temp: \n        result.append(temp) \n    return result",
        "n = 2\nresult = []\ni = 0\nwhile i < len(input_list):\n    if i % n == 0:\n        result.append(input_list[i+n-1])\n    else:\n        result.append(input_list[i])\n    i += 1\ni = 0\nwhile i < len(result):\n    if i % n == 0:\n        result[i], result[i+n-1] = result[i+n-1], result[i]\n    i += 1\nreturn result",
        "sum_Range_list = lambda lst, start, end: sum(lst[start:end+1])",
        "def are_Equal(arr1,arr2,m,n): \n    if len(arr1)!= len(arr2): \n        return False \n    for i in range(len(arr1)): \n        if arr1[i]!= arr2[i]: \n            return False \n    return True",
        "set1 = set(tuple1)\nset2 = set(tuple2)\nreturn set1.issubset(set2)",
        "zip(*[tuple(x) for x in matrix])",
        "from collections import defaultdict\n\ndef grouping_dictionary(lst):\n    result = defaultdict(list)\n    for key, value in lst:\n        result[key].append(value)\n    return dict(result)",
        "def rectangle_perimeter(length,width): \n    return 2*(length+width)",
        "sum = 0\nfor i in range(1, 3):\n    sum += i**5",
        "sorted([abs(a-b) for a,b in zip(arr1,arr2)])",
        "import math\n\ndef first_Digit(n):\n    factorial = math.factorial(n)\n    str_factorial = str(factorial)\n    for i in range(len(str_factorial)):\n        if str_factorial[i]!= '0':\n            return int(str_factorial[i])",
        "from collections import Counter\n\ndef max_occurrences(lst):\n    count = Counter(lst)\n    return max(count, key=count.get)",
        "def Repeat(lst):\n    result = []\n    for i in set(lst):\n        if lst.count(i) > 1:\n            result.append(i)\n    return result",
        "min1, max1, min2, max2 = 5, 10, 1, 5 \nreturn min1, max2",
        "def max_sum_of_three_consecutive(arr, n): \n    dp = [0]*n \n    dp[0] = arr[0] \n    dp[1] = max(arr[0], arr[1]) \n    for i in range(2, n): \n        dp[i] = max(dp[i-1], dp[i-2] + arr[i]) \n    return dp[n-1]",
        "dict({k: sorted(v) for k, v in d.items()})",
        "k = x - y",
        "def average_Even(n): \n    sum = 0 \n    count = 0 \n    for i in range(2, n+1, 2): \n        sum += i \n        count += 1 \n    return sum / count",
        "def move_last(lst): \n    if len(lst) == 0: \n        return lst \n    else: \n        return lst[1:] + [lst[0]]",
        "def count_char(s, c): \n    return s.count(c)",
        "def Check_Vow(s, vowels): \n    return sum(1 for char in s if char.upper() in vowels)",
        "def replace(s, c): \n    return s.replace(c, c)",
        "import re\n\ndef check_IP(ip):\n    pattern = re.compile(r\"^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\")\n    if pattern.match(ip):\n        return 'Valid IP address'\n    else:\n        return 'Invalid IP address'",
        "def decreasing_trend(sequence): \n    for i in range(1, len(sequence)): \n        if sequence[i-1] >= sequence[i]: \n            return False \n    return True",
        "x = x | (x & -x)",
        "max_of_three = lambda a, b, c: max(a, b, c)",
        "int(\"\".join(map(str, [1,2,3])))",
        "from collections import OrderedDict\n\ndef remove_duplicate(s):\n    return''.join(OrderedDict.fromkeys(s.split()))",
        "def sum_nums(a, b, min_range, max_range):\n    if min_range <= a + b <= max_range:\n        return 20\n    else:\n        return a + b",
        "import re\n\ndef remove_extra_char(s):\n    return re.sub(r'[^a-zA-Z0-9]', '', s)",
        "def validity_triangle(a,b,c):\n    if a+b>c and a+c>b and b+c>a:\n        return True\n    else:\n        return False",
        "remove_spaces = lambda s: s.replace(\" \", \"\")",
        "def access_key(d, index):\n    return list(d.keys())[index]",
        "def increasing_trend(seq):\n    for i in range(1, len(seq)):\n        if seq[i] <= seq[i-1]:\n            return False\n    return True",
        "def smallest_Divisor(n): \n    if n < 2: \n        return n \n    for i in range(2, int(n**0.5) + 1): \n        if n % i == 0: \n            return i \n    return n",
        "mul_list = lambda x, y: list(map(lambda a, b: a * b, x, y))",
        "def sum_Square(n):\n    for i in range(int(n**0.5) + 1):\n        j = (n - i**2)**0.5\n        if j == int(j):\n            return True\n    return False",
        "def count_Char(s, char): \n    return s.count(char)",
        "def sum_Of_Primes(n): \n    def is_prime(num): \n        if num < 2: \n            return False \n        for i in range(2, int(num**0.5) + 1): \n            if num % i == 0: \n                return False \n        return True \n    return sum(num for num in range(2, n+1) if is_prime(num))",
        "dict([(i, (list(input)).count(i)) for i in set(input)])",
        "def recur_gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return recur_gcd(b, a % b)",
        "def len_complex(real, imag): \n    return (real**2 + imag**2)**0.5",
        "def min_jumps(arr, end): \n    jumps = [float('inf')] * len(arr) \n    jumps[0] = 0 \n    for i in range(len(arr)): \n        for j in range(i+1, min(i+arr[i]+1, len(arr))): \n            jumps[j] = min(jumps[j], jumps[i] + 1) \n    return jumps[end]",
        "def mul_consecutive_nums(lst):\n    result = []\n    i = 0\n    while i < len(lst):\n        count = 1\n        while i + 1 < len(lst) and lst[i] == lst[i+1]:\n            i += 1\n            count += 1\n        result.append(lst[i] * count)\n        i += 1\n    return result",
        "def group_element(lst):\n    result = {}\n    for key, value in lst:\n        if value in result:\n            result[value].append(key)\n        else:\n            result[value] = [key]\n    return result",
        "import math\n\ndef last_Two_Digits(n):\n    return int(str(math.factorial(n))[-2:])",
        "import re\n\ndef remove_multiple_spaces(s):\n    return re.sub(' +','', s)",
        "set([item for sublist in list(d.values()) for item in sublist])",
        "def check_greater(t1, t2): \n    return all(i < j for i, j in zip(t1, t2))",
        "zip_list = lambda x, y: [a + b for a, b in zip(map(lambda z: list(z), x), map(lambda z: list(z), y))]",
        "filter(lambda x: x%2==0, [1, 2, 3, 5, 7, 8, 9, 10]).__len__()",
        "sorted(dict.items(), key=lambda x: x[0][0]*x[0][1])",
        "def min_Swaps(s1, s2): \n    s1 = list(s1) \n    s2 = list(s2) \n    swaps = 0 \n    for i in range(len(s1)): \n        if s1[i]!= s2[i]: \n            for j in range(i+1, len(s1)): \n                if s1[j] == s2[i]: \n                    s1[i], s1[j] = s1[j], s1[i] \n                    swaps += 1 \n                    break \n    return swaps",
        "def count_range_in_list(lst, start, end): \n    return sum(1 for x in lst if start <= x <= end)",
        "def equilibrium_index(arr):\n    total_sum = sum(arr)\n    for i in range(len(arr)):\n        if total_sum - arr[i] == sum(arr[:i] + arr[i+1:]):\n            return i\n    return -1",
        "def removals(arr, amin, amax, k):\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    removed = 0\n    while left <= right:\n        if arr[right] - arr[left] > k:\n            removed += 1\n            left += 1\n        else:\n            right -= 1\n    return removed + len(arr) - amax - amin + 1",
        "def is_key_present(dictionary, key): \n    if key in dictionary: \n        return True \n    else: \n        return False",
        "def harmonic_sum(n): \n    sum = 0.0 \n    for i in range(1, n): \n        sum += 1.0 / i \n    return sum",
        "def sort_sublists(sublists):\n    return sorted(sublists, key=lambda x: (len(x), x))",
        "def is_subset(arr1, m, arr2, n): \n    arr1.sort() \n    arr2.sort() \n    i = 0 \n    j = 0 \n    while i < m and j < n: \n        if arr1[i] < arr2[j]: \n            i += 1 \n        elif arr1[i] > arr2[j]: \n            j += 1 \n        else: \n            i += 1 \n            j += 1 \n    return i == m and j == n",
        "def count_Set_Bits(n):\n    count = 0\n    for i in range(1, n+1):\n        while i:\n            count += i & 1\n            i >>= 1\n    return count",
        "def Convert(s): \n    return s.split()",
        "dict((k, len(list(g))) for k, g in itertools.groupby(sorted([x for y in [(x,) for x, y in input_tuple] for x in y], key=lambda x: x)))",
        "def front_and_rear(record):\n    return (record[0], record[-1])",
        "def product_Equal(n):\n    digits = [int(i) for i in str(n)]\n    even_product = 1\n    odd_product = 1\n    for i in range(len(digits)):\n        if i % 2 == 0:\n            even_product *= digits[i]\n        else:\n            odd_product *= digits[i]\n    return even_product == odd_product",
        "setdefaultdict(lambda: set(), *([x] if isinstance(x, list) else [x] for x in [10, 20], [40], [30, 56, 25], [10, 20], [33], [40])).values()",
        "def check_valid(t): \n    return all(t)",
        "def count_Fac(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            while n % i == 0:\n                n //= i\n            if is_prime(i):\n                count += 1\n    if n > 1:\n        if is_prime(n):\n            count += 1\n    return count",
        "int(str_to_tuple(\"1, -5, 4, 6, 7\"))",
        "def rombus_perimeter(a): \n    return 4*a",
        "import math\n\ndef sd_calc(lst):\n    mean = sum(lst) / len(lst)\n    return math.sqrt(sum((x - mean) ** 2 for x in lst) / len(lst))",
        "def alternate_elements(lst):\n    return lst[::2]",
        "import re\n\ndef text_match(text):\n    pattern = re.compile('a.*b')\n    if re.match(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'No match found!'",
        "def add_dict_to_tuple(t, d): \n    return t + (d,)",
        "def maxAverageOfPath(matrix, n):\n    m = [[0.0] * n for _ in range(n)]\n    m[0][0] = matrix[0][0]\n    for i in range(1, n):\n        m[0][i] = m[0][i-1] + matrix[0][i]\n    for i in range(1, n):\n        m[i][0] = m[i-1][0] + matrix[i][0]\n    for i in range(1, n):\n        for j in range(1, n):\n            m[i][j] = max(m[i-1][j], m[i][j-1]) + matrix[i][j]\n    return m[n-1][n-1] / (n * n)",
        "def filter_data(students,height,width):\n    return {name: (h, w) for name, (h, w) in students.items() if h == height and w == width}",
        "map(lambda x, y: x.count(y), [1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9])",
        "def power_base_sum(base, power): \n    result = 0 \n    num = 1 \n    for _ in range(power): \n        num = num * base \n    for digit in str(num): \n        result += int(digit) \n    return result",
        "import re\n\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)",
        "def multiply_elements(t):\n    return tuple(a*b for a, b in zip(t, t[1:]))",
        "import re\n\ndef remove_char(s):\n    return re.sub('[^a-zA-Z0-9]', '', s)",
        "def sum_list(list1, list2):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i] + list2[i])\n    return result",
        "lambda x, y: [i+j for i, j in zip(x, y)]",
        "def consecutive_duplicates(lst):\n    if len(lst) == 0:\n        return lst\n    result = [lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i]!= lst[i-1]:\n            result.append(lst[i])\n    return result",
        "import math\n\ndef lateralsurface_cone(radius,height):\n    return math.pi * radius * (radius + math.sqrt(height**2 + radius**2))",
        "replace_specialchar = lambda s: s.replace(' ', ':').replace(',', ':').replace('.', ':')",
        "def find_first_occurrence(arr, target): \n    left, right = 0, len(arr) - 1 \n    while left <= right: \n        mid = (left + right) // 2 \n        if arr[mid] < target: \n            left = mid + 1 \n        elif arr[mid] > target: \n            right = mid - 1 \n        else: \n            if mid == 0 or arr[mid - 1] < target: \n                return mid \n            right = mid - 1 \n    return -1",
        "def sum_Of_Subarray_Prod(arr,n):\n    res = 0\n    for i in range(n):\n        curr = 1\n        for j in range(i,n):\n            curr *= arr[j]\n            res += curr\n    return res",
        "bin((~((1 << (8)) - 1) & ((1 << (8)) - 1) ^ num) >> (7))",
        "def left_insertion(lst, value): \n    left = 0 \n    right = len(lst) \n    while left < right: \n        mid = (left + right) // 2 \n        if lst[mid] < value: \n            left = mid + 1 \n        else: \n            right = mid \n    return left",
        "import re\n\ndef check_str(s):\n    if re.match('^[aeiouAEIOU].*', s):\n        return 'Valid'\n    else:\n        return 'Invalid'",
        "math.pow(2, 1)",
        "def find_Index(n):\n    i = 1\n    count = 1\n    while True:\n        tri = (i * (i + 1)) // 2\n        count += len(str(tri))\n        if count == n:\n            return i\n        i += 1",
        "dict({k: v for k, v in zip([i for i in range(0, len((1, 5, 7, 10, 13, 5)), 2)], (1, 5, 7, 10, 13, 5)[1:])})",
        "def all_Characters_Same(s): \n    return len(set(s)) == 1",
        "import math\n\ndef area_tetrahedron(a):\n    s = a / 3\n    return math.sqrt(3 * math.pow(s, 3))",
        "def rotate_right(lst, k, n): \n    k = k % n \n    return lst[-k:] + lst[:-k]",
        "any(None in t)",
        "def divisible_by_digits(start, end): \n    result = []\n    for num in range(start, end+1): \n        is_divisible = True \n        for digit in str(num): \n            if num % int(digit)!= 0: \n                is_divisible = False \n                break \n        if is_divisible: \n            result.append(num) \n    return result",
        "math.pi*4*(45/360)",
        "def lcs_of_three(s1, s2, s3, m, n, p):\n    dp = [[0] * (p + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(p + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif s2[i - 1] == s3[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[n][p]",
        "import re\n\ndef capital_words_spaces(s):\n    return re.sub(r'(?<!^)(?=[A-Z])','', s)",
        "def sort_numeric_strings(lst):\n    return sorted([int(x) for x in lst])",
        "def add_tuple(lst, t): \n    lst += list(t) \n    return lst",
        "def check_min_heap(arr, n):\n    for i in range(n):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and arr[i] > arr[left]:\n            return False\n        if right < n and arr[i] > arr[right]:\n            return False\n    return True",
        "def jacobsthal_num(n): \n    if n == 1: \n        return 0 \n    elif n == 2: \n        return 1 \n    else: \n        a, b = 0, 1 \n        for _ in range(2, n): \n            a, b = b, a + b \n        return b",
        "lambda lst, k: sorted(lst, key=lambda x: x[1])[:k]",
        "def extract_index_list(list1, list2, list3):\n    index_list = [i for i in range(len(list1)) if i in list2 and i in list3]\n    return index_list",
        "def second_smallest(numbers): \n    numbers = list(set(numbers)) \n    numbers.sort() \n    return numbers[1]",
        "re.compile('a(b)?').match('ac')",
        "def count_reverse_pairs(lst):\n    count = 0\n    for word in lst:\n        if word == word[::-1]:\n            count += 1\n    return str(count)",
        "def unique_sublists(sublists):\n    count_dict = {}\n    for sublist in sublists:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict",
        "def is_decimal(s): \n    try: \n        float(s) \n        return '.' in s or s.replace('.','').isdigit() \n    except ValueError: \n        return False",
        "def unique_Element(arr,n):\n    count = {}\n    for i in arr:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n    for i in count:\n        if count[i] == 1:\n            return 'YES'\n    return 'NO'",
        "math.sqrt((math.sin(math.radians(45))*9)**2+(math.cos(math.radians(45))*9)**2)",
        "def check_monthnumber_number(month_number): \n    if month_number in [1,3,5,7,8,10,12]: \n        return False \n    else: \n        return True",
        "sorted_list = sorted(input_list)\nmin_diff = float('inf')\nfor i in range(1, len(sorted_list)):\n    min_diff = min(min_diff, sorted_list[i] - sorted_list[i-1])\nreturn min_diff",
        "def number_ctr(s): \n    return sum(c.isdigit() for c in s)",
        "def is_polite(n): \n    def polite_numbers():\n        a = 0\n        b = 1\n        polite = set()\n        while a < n:\n            if a % 2 == 0 and b % 2 == 0:\n                polite.add(a + b)\n            a += 1\n            b += 1\n        return sum(polite)",
        "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]",
        "def get_Pairs_Count(lst, sum, k): \n    lst.sort()\n    i = 0\n    count = 0\n    for j in range(len(lst)):\n        while i < j and lst[i] + lst[j] > sum:\n            i += 1\n        while i < j and lst[i] + lst[j] < sum:\n            i += 1\n        while i < j and lst[i] + lst[j] == sum:\n            count += 1\n            i += 1\n            if i < j and lst[i] == lst[i - 1]:\n                i += 1\n    return count",
        "def check_Odd_Parity(n): \n    return n % 2!= 0",
        "set(a) - set(b) | list(set(a) & set(b))",
        "sum((i**4 for i in range(1, 2*input()+1, 2)))",
        "def check_expression(expression):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in expression:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or mapping[char]!= stack.pop():\n                return False\n    return not stack",
        "def remove_length(s, k): \n    words = s.split() \n    return''.join(word for word in words if len(word)!= k)",
        "occurance_substring = lambda s, sub: (sub, s.find(sub), s.find(sub) + len(sub))",
        "import re\n\ndef check_email(email):\n    pattern = r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"\n    if re.match(pattern, email):\n        return 'Valid Email'\n    else:\n        return 'Invalid Email'",
        "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True",
        "vowels = 'aeiouAEIOU'\ndef count_vowels(s):\n    count = 0\n    for i in range(len(s)):\n        if i > 0 and s[i-1] in vowels:\n            if i < len(s) - 1 and s[i+1] in vowels:\n                count += 1\n        elif i < len(s) - 1 and s[i+1] in vowels:\n            count += 1\n    return count",
        "def find_Sum(arr,n): \n    frequency = {} \n    for num in arr: \n        if num in frequency: \n            frequency[num] += 1 \n        else: \n            frequency[num] = 1 \n    sum = 0 \n    for num in arr: \n        if frequency[num] == 1: \n            sum += num \n    return sum",
        "def pack_consecutive_duplicates(lst):\n    result = []\n    current = [lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i-1]:\n            current.append(lst[i])\n        else:\n            result.append(current)\n            current = [lst[i]]\n    result.append(current)\n    return result",
        "def count_unique_sublists(lists):\n    return {tuple(sublist): lists.count(sublist) for sublist in set(tuple(sublist) for sublist in lists)}",
        "def find_combinations(tuple_list):\n    combinations = []\n    for i in range(len(tuple_list)):\n        for j in range(i+1, len(tuple_list)):\n            combinations.append((tuple_list[i][0] + tuple_list[j][0], tuple_list[i][1] + tuple_list[j][1]))\n            combinations.append((tuple_list[i][0] + tuple_list[j][1], tuple_list[i][1] + tuple_list[j][0]))\n    return combinations",
        "def count_Divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    if count % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"",
        "def Odd_Length_Sum(arr):\n    n = len(arr)\n    total = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            subarray = arr[i:j]\n            if len(subarray) % 2!= 0:\n                total += sum(subarray)\n    return total",
        "max_val = max(r, g, b)\nmin_val = min(r, g, b)\ndelta = max_val - min_val\nif delta == 0:\n    h = 0\nelse:\n    if r == min_val:\n        h = 60 * ((g - b) / delta) % 360\n    elif g == min_val:\n        h = 60 * ((b - r) / delta) + 120\n    else:\n        h = 60 * ((r - g) / delta) + 240\nv = max_val\ns = delta / max_val if max_val!= 0 else 0\nreturn h, s, v",
        "def mul_even_odd(lst):\n    even = next((x for x in lst if x % 2 == 0), None)\n    odd = next((x for x in lst if x % 2!= 0), None)\n    return even * odd if even is not None and odd is not None else None",
        "int_tuple = eval(tuple_str)",
        "bisect.bisect_right([1,2,4,5],6)",
        "def text_match_three(text):\n    if text.startswith('a') and len(text) > 1 and text[1:4] == 'bb':\n        return 'Matched!'\n    else:\n        return 'Not matched!'",
        "new_tuple = lambda s, l: (s[0], s[1], l)",
        "def perimeter_polygon(n, s): \n    return n * s",
        "def even_position(lst):\n    return all(i%2==0 and isinstance(num,int) and num%2==0 for i,num in enumerate(lst))",
        "def remove_nested(t): \n    result = [] \n    for item in t: \n        if isinstance(item, tuple): \n            result.extend(remove_nested(item)) \n        else: \n            result.append(item) \n    return tuple(result)",
        "def count_list(lst): \n    return len(lst)",
        "def last(arr, low, high): \n    if high < low: \n        return -1 \n    if high == low: \n        if arr[low] == arr[high]: \n            return low \n        else: \n            return -1 \n    mid = (low + high) // 2 \n    if arr[mid] < arr[high]: \n        return last(arr, mid + 1, high) \n    elif arr[mid] > arr[high]: \n        return last(arr, low, mid - 1) \n    else: \n        right = mid - 1 \n        while right >= low and arr[right] == arr[mid]: \n            right -= 1 \n        if right >= low and arr[right] == arr[mid]: \n            return right \n        return mid",
        "if re.match(r'a.*b', s): return 'Found a match!'",
        "import heapq\n\ndef cheap_items(dataset, n):\n    return heapq.nsmallest(n, dataset, key=lambda x: x['price'])",
        "def return_sum(d):\n    return sum(d.values())",
        "sum_in_Range = lambda l, r: sum(i for i in range(l, r+1) if i % 2!= 0)",
        "_sum = lambda arr: sum(arr)",
        "n = int(input())\nk = int(input())\nn = n << k\nn = n & ((1 << k) - 1)\nprint(n)",
        "def remove_all_spaces(s): \n    return s.replace(\" \",\"\")",
        "def test_three_equal(a, b, c): \n    count = 0 \n    if a == b: \n        count += 1 \n    if a == c: \n        count += 1 \n    if b == c: \n        count += 1 \n    return count",
        "def count_Rotation(arr, n): \n    for i in range(n): \n        arr = arr[1:] + [arr[0]] \n        if sorted(arr) == arr: \n            return i + 1 \n    return -1",
        "import math\n\ndef is_Perfect_Square(n):\n    return math.sqrt(n) % 1 == 0",
        "def is_Product_Even(numbers, product): \n    return product % 2 == 0",
        "max_sum_list = lambda lst: max(lst, key=sum)",
        "max_run_uppercase = lambda s: max(len(r) for r in ''.join(c for c in s if c.isupper()).split('a'))",
        "def first_odd(numbers): \n    for num in numbers: \n        if num % 2!= 0: \n            return num",
        "def check_K(t, k): \n    return k in t",
        "zip(*((i,) + t for i, t in enumerate((2, 3, 4))), (1, 2, 3))",
        "list(map(lambda x: x[1] * x[0], [(4, 'p'), (2, 'q'), (0, '-'), (-2, '-')])),",
        "def check_identical(list1, list2):\n    return sorted(list1) == sorted(list2)",
        "def road_rd(s): \n    if 'road' in s: \n        return s.replace('road', 'rd.') \n    else: \n        return s",
        "def string_length(s): \n    return len(s)",
        "def rombus_area(a, b): \n    return (a*b)/2",
        "count_zero = 0\ncount_one = 0\ncount_two = 0\n\nfor num in arr:\n    if num == 0:\n        count_zero += 1\n    elif num == 1:\n        count_one += 1\n    else:\n        count_two += 1\n\nreturn [0]*count_zero + [1]*count_one + [2]*count_two",
        "return ()",
        "filter(lambda x: x % 19 == 0 or x % 13 == 0, [19, 65, 57, 39, 152, 639, 121, 44, 90, 190])",
        "def lower_ctr(s): \n    return sum(1 for c in s if 'a' <= c <= 'z')",
        "def count_duplic(lst):\n    result = []\n    freq = []\n    i = 0\n    while i < len(lst):\n        count = 1\n        while i + 1 < len(lst) and lst[i] == lst[i+1]:\n            i += 1\n            count += 1\n        result.append(lst[i])\n        freq.append(count)\n        i += 1\n    return result, freq",
        "def check_monthnum_number(monthnum): \n    if monthnum in [1, 3, 5, 7, 8, 10, 12]: \n        return False \n    elif monthnum == 2: \n        return True \n    else: \n        return True",
        "update_dict = {**dict1, **dict2}",
        "def pass_validity(password):\n    return len(password)<8",
        "import re\n\ndef check_substring(s, sub):\n    if re.match(sub, s):\n        return'string starts with the given substring'\n    else:\n        return'string doesnt start with the given substring'",
        "def remove_even(numbers): \n    return [num for num in numbers if num % 2!= 0]",
        "def access_elements(lst, indices):\n    return [lst[i] for i in indices]",
        "if a>b and a>c:\n    if a**2 == b**2 + c**2:\n        return \"Right-angled Triangle\"\n    else:\n        return \"Obtuse-angled Triangle\"\nelif b>a and b>c:\n    if b**2 == a**2 + c**2:\n        return \"Right-angled Triangle\"\n    else:\n        return \"Obtuse-angled Triangle\"\nelif c>a and c>b:\n    if c**2 == a**2 + b**2:\n        return \"Right-angled Triangle\"\n    else:\n        return \"Obtuse-angled Triangle\"",
        "sum_column = lambda lst, col: sum(row[col] for row in lst)",
        "def count_alpha_dig_spl(s): \n    alpha = 0 \n    dig = 0 \n    spl = 0 \n    for i in s: \n        if i.isalpha(): \n            alpha += 1 \n        elif i.isdigit(): \n            dig += 1 \n        else: \n            spl += 1 \n    return alpha, dig, spl",
        "def second_frequent(seq):\n    freq = {}\n    for item in seq:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    max_freq = max(freq.values())\n    second_max_freq = max_freq\n    second_max_item = None\n    for item, value in freq.items():\n        if value == max_freq:\n            continue\n        if value > second_max_freq:\n            second_max_freq = value\n            second_max_item = item\n    return second_max_item",
        "round_up = lambda n, digits: round(n, digits) if digits < 0 else round(n, digits)",
        "def count_Pairs(arr,n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            if arr[i] == arr[j]:\n                count += 1\n    return count",
        "import re\n\ndef extract_max(s):\n    return max(map(int, re.findall('\\d+', s)))",
        "def get_key(d): \n    return list(d.keys())",
        "n = int(input())\nmatrix = [[0 for _ in range(n)] for _ in range(n)]\nnum = 1\ni, j = 0, 0\ndi, dj = 0, 1\nfor _ in range(n*n):\n    matrix[i][j] = num ** 2\n    num += 1\n    matrix[i][j] = num ** 2\n    if i - di < 0 or i + di >= n or matrix[i-di][j]!= 0:\n        di, dj = dj, -di\n    i += di\n    j += dj",
        "def slope(x1, y1, x2, y2): \n    if x2 - x1 == 0: \n        return \"undefined\" \n    return (y2 - y1) / (x2 - x1)",
        "def max_sub_array_sum(arr,n):\n    max_sum = float('-inf')\n    current_sum = 0\n    start = 0\n    end = 0\n    temp_start = 0\n    for i in range(n):\n        current_sum += arr[i]\n        if current_sum > max_sum:\n            max_sum = current_sum\n            start = temp_start\n            end = i\n        if current_sum < 0:\n            current_sum = 0\n            temp_start = i+1\n    return end-start+1",
        "sum([i**3 for i in range(1, 3*2+1, 2)])",
        "def min_Swaps(s1, s2):\n    n = len(s1)\n    swaps = 0\n    for i in range(n):\n        if s1[i]!= s2[i]:\n            j = i\n            while s1[j]!= s2[i]:\n                j += 1\n            s1 = s1[:i] + s2[i] + s1[i+1:j] + s1[j:i] + s1[j+1:]\n            swaps += 1\n    return swaps",
        "def sort_tuple(tuples): \n    return sorted(tuples, key=lambda x: x[0])",
        "b = (b**2 - 4*a*c)**0.5; if b == int(b) and (int(b) > 0): return \"Yes\" else: return \"No\"",
        "def get_inv_count(arr, n): \n    inv_count = 0 \n    for i in range(n): \n        for j in range(i+1, n): \n            if arr[i] > arr[j]: \n                inv_count += 1 \n    return inv_count",
        "def get_odd_occurence(arr, n): \n    count = [0] * n \n    for num in arr: \n        count[num] += 1 \n    for i in range(n): \n        if count[i] % 2!= 0: \n            return i",
        "heapq.heappush(heap,[n*prime[0],n,prime[0]]) for i in range(k): heapq.heappush(heap,[n*prime[i],n,prime[i]]) ugly_nums = [1] while len(ugly_nums)<n: curr = heapq.heappop(heap) ugly_nums.append(curr[0]) for i in range(k): heapq.heappush(heap,[curr[0]*prime[i],len(ugly_nums),prime[i]]) return ugly_nums[-1]",
        "k = 0\ndef get_Number(n, k):\n    global k\n    result = []\n    for i in range(1, n+1):\n        if i % 2!= 0:\n            result.append(i)\n            k += 1\n            if k == k:\n                return result[-1]",
        "import math\n\ndef find_Digits(n):\n    f = math.factorial(n)\n    return len(str(f))",
        "def find_platform(arrivals, departures, n):\n    platforms = 0\n    max_platforms = 0\n    time = 0\n    arrival = 0\n    departure = 0\n    i = 0\n    j = 0\n    while i < n or j < n:\n        if arrival < departure:\n            if i < n:\n                arrival = arrivals[i]\n                i += 1\n            platforms -= 1\n        else:\n            if j < n:\n                departure = departures[j]\n                j += 1\n            platforms += 1\n        time = max(time, arrival)\n        max_platforms = max(max_platforms, platforms)\n    return max_platforms",
        "lcopy = lambda x: list(x)",
        "def area_trapezium(a, b, h): \n    return (a + b) * h / 2",
        "def Sum(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    sum = 0\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            sum += i\n    return sum",
        "def is_triangleexists(a,b,c): \n    if a+b>c and a+c>b and b+c>a: \n        return True \n    else: \n        return False",
        "def Sum_of_Inverse_Divisors(n, k):\n    total = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            total += 1 / i\n    return total",
        "def remove_negs(lst): \n    return [i for i in lst if i >= 0]",
        "def sum_of_odd_Factors(n): \n    sum = 0 \n    for i in range(1, n + 1): \n        if n % i == 0 and i % 2!= 0: \n            sum += i \n    return sum",
        "import heapq\n\ndef raw_heap(lst):\n    return list(heapq.heapify(lst))[0]",
        "def check_Even_Parity(n): \n    count = 0 \n    while n > 0: \n        count += n % 2 \n        n = n // 2 \n    return count % 2 == 0",
        "def find_Min_Swaps(arr,n): \n    arr.sort() \n    map = {} \n    for i in range(n): \n        map[arr[i]] = i \n    ans = 0 \n    for i in range(n): \n        if arr[i]!= i: \n            ans += 1 \n            arr[map[i]], arr[i] = arr[i], arr[map[i]] \n            map[arr[i]], map[i] = map[i], map[arr[i]] \n    return ans",
        "map(lambda x: list(x), ['Red', 'Blue', 'Black', 'White', 'Pink'])",
        "len([i for i in input_list if isinstance(i, list)])**2",
        "def sub_lists(lst):\n    sub_lists = [[]]\n    for i in range(len(lst)):\n        sub_lists += [curr + [lst[i]] for curr in sub_lists]\n    return sub_lists",
        "import re\n\ndef check_alphanumeric(s):\n    if re.match('^[a-zA-Z0-9]+$', s):\n        return 'Keep'\n    else:\n        return 'Discard'",
        "sorted_anagram = lambda s, lst: [i for i in lst if sorted(i) == sorted(s)]",
        "def n_common_words(text, n):\n    words = text.split()\n    word_count = {}\n    for word in words:\n        word = word.lower()\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    common_words = sorted(word_count.items(), key=lambda x: x[1], reverse=True)[:n]\n    return common_words",
        "def find_longest_conseq_subseq(arr, n): \n    arr_set = set(arr) \n    longest_subseq = 0 \n    for num in arr_set: \n        if num - 1 not in arr_set: \n            curr_num = num \n            curr_subseq = 1 \n            while curr_num + 1 in arr_set: \n                curr_num += 1 \n                curr_subseq += 1 \n            longest_subseq = max(longest_subseq, curr_subseq) \n    return longest_subseq",
        "filter(lambda s: s == s[::-1], [\"php\", \"res\", \"Python\", \"abcd\", \"Java\", \"aaa\"])",
        "lambda x, n: list(map(lambda y: y*n, x))",
        "def check_monthnumb(month_name): \n    month_dict = {\"January\":31,\"March\":31,\"May\":31,\"July\":31,\"August\":31,\"October\":31,\"December\":31} \n    return month_name in month_dict",
        "sum(sum(x) % 2 for x in [1,2,3,4,5,6,7,8,9])!= 0 and 1 or 0",
        "def length_Of_Last_Word(s): \n    return len(s.split()[-1])",
        "def remove_list_range(lst, min_val, max_val):\n    return [sublist for sublist in lst if min_val <= max(sublist) <= max_val]",
        "filter(lambda x: x > 0, [2, 4, -6, -9, 11, -12, 14, -5, 17])",
        "def are_Rotations(str1, str2):\n    if len(str1)!= len(str2):\n        return False\n    return str1 in str2+str2",
        "def check_subset(subset, superset):\n    subset.sort()\n    superset.sort()\n    i = j = 0\n    while i < len(subset) and j < len(superset):\n        if subset[i] < superset[j]:\n            i += 1\n        elif subset[i] > superset[j]:\n            return False\n        else:\n            i += 1\n            j += 1\n    return i == len(subset)",
        "def fibonacci(n): \n    if n <= 0: \n        return 0 \n    elif n == 1: \n        return 1 \n    else: \n        return fibonacci(n-1) + fibonacci(n-2)",
        "def check_Concat(s, t):\n    if len(s) % len(t)!= 0:\n        return False\n    for i in range(0, len(s), len(t)):\n        if s[i:i+len(t)]!= t:\n            return False\n    return True",
        "min_difference = lambda tuples: min(abs(a - b) for a, b in tuples)",
        "def lcm(a, b):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    return a * b // gcd(a, b)",
        "def sort_String(s):\n    return \"\".join(sorted(s))",
        "def check_tuples(t, k): \n    return len(set(t)) == len(k)",
        "import re\n\ndef text_match(s):\n    pattern = re.compile('a.*b')\n    if pattern.match(s):\n        return 'Matched!'\n    else:\n        return 'Not matched!'",
        "def Check_Solution(a, b, c):\n    d = b**2 - 4*a*c\n    if d > 0:\n        return \"2 solutions\"\n    elif d == 0:\n        return \"1 solution\"\n    else:\n        return \"no solution\"",
        "def sum_even_odd(lst):\n    even_sum = sum(i for i in lst if i % 2 == 0)\n    odd_sum = sum(i for i in lst if i % 2!= 0)\n    return even_sum + odd_sum",
        "def parallelogram_perimeter(a, b): \n    return 2*(a+b)",
        "filter(lambda x: x % 2 == 0 and x % 4 == 0, [19, 65, 57, 39, 152, 639, 121, 44, 90, 190])",
        "def all_Bits_Set_In_The_Given_Range(n, start, end):\n    for i in range(start, end+1):\n        if (n & (1 << i)) == 0:\n            return False\n    return True",
        "def is_Isomorphic(s1, s2): \n    if len(s1)!= len(s2): \n        return False \n    map1 = {} \n    map2 = {} \n    for i in range(len(s1)): \n        if s1[i] in map1 and map1[s1[i]]!= s2[i]: \n            return False \n        if s2[i] in map2 and map2[s2[i]]!= s1[i]: \n            return False \n        map1[s1[i]] = s2[i] \n        map2[s2[i]] = s1[i] \n    return True",
        "def sum_num(numbers):\n    return sum(numbers) / len(numbers)",
        "def is_odd(n): \n    return n & 1",
        "def substract_elements(tuples1, tuples2):\n    result = []\n    for t1, t2 in zip(tuples1, tuples2):\n        result.append(tuple(x-y for x, y in zip(t1, t2)))\n    return tuple(result)",
        "def reverse_list_lists(list_of_lists):\n    return [i[::-1] for i in list_of_lists]",
        "set1 = set([1,2,3,4])\nset2 = set([1,2,3])\nfor num in set1:\n    if num in set2:\n        continue\n    return num",
        "def same_Length(a, b): \n    return str(a).count(str(a)[0]) == str(b).count(str(b)[0])",
        "def remove_spaces(s): \n    return''.join(s.split())",
        "[3, 5, 9]",
        "float_to_tuple = lambda s: tuple(map(float, s.split(',')))",
        "def max_sum_subseq(arr):\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl)",
        "sorted(lst, key=lambda x: x[-1])",
        "def is_Word_Present(sentence, word): \n    return word in sentence",
        "def extract_elements(lst, n):\n    result = []\n    i = 0\n    while i < len(lst):\n        count = 1\n        while i + 1 < len(lst) and lst[i] == lst[i+1]:\n            i += 1\n            count += 1\n        if count >= n:\n            result.extend([lst[i]] * n)\n        i += 1\n    return result",
        "def check(arr, k):\n    arr.sort()\n    if k == len(arr):\n        return True\n    if k == 1:\n        return False\n    if arr[0] == arr[-1]:\n        return True\n    if arr[0] == arr[k-1]:\n        return True\n    if arr[-1] == arr[k]:\n        return True\n    return False",
        "def match_num(s): \n    return s.startswith('5-')",
        "def smallest_multiple(n):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n    result = 1\n    for i in range(1, n+1):\n        result = lcm(result, i)\n    return result",
        "def add_dict(dict1, dict2):\n    result = {}\n    for key in set(list(dict1.keys()) + list(dict2.keys())):\n        result[key] = dict1.get(key, 0) + dict2.get(key, 0)\n    return result",
        "def count_Unset_Bits(n):\n    count = 0\n    for i in range(1, n+1):\n        while i:\n            count += i & 1\n            i >>= 1\n    return count",
        "def even_num(n): \n    return n % 2 == 0",
        "def sum_of_square(n):\n    sum = 0\n    for i in range(n+1):\n        sum += (binomial_coefficient(i, n))**2\n    return sum\n\ndef binomial_coefficient(i, n):\n    if i == 0 or i == n:\n        return 1\n    else:\n        return binomial_coefficient(i-1, n) + binomial_coefficient(i, n-1)",
        "import re\n\ndef extract_date(url):\n    pattern = re.compile(r'(\\d{4})/(\\d{2})/(\\d{2})')\n    match = pattern.search(url)\n    if match:\n        return (match.group(1), match.group(2), match.group(3))",
        "def lucky_num(n): \n    lucky_numbers = [1]\n    i = 2 \n    while len(lucky_numbers) < n: \n        is_lucky = True \n        for j in range(2, int(i ** 0.5) + 1): \n            if i % j == 0: \n                is_lucky = False \n                break \n        if is_lucky: \n            lucky_numbers.append(i) \n        i += 1 \n    return lucky_numbers",
        "def find_fixed_point(arr, n): \n    for i in range(n): \n        if arr[i] == i: \n            return i \n    return -1",
        "def previous_palindrome(n): \n    i = n - 1 \n    while not str(i) == str(i)[::-1]: \n        i -= 1 \n    return i",
        "def check_date(day, month, year): \n    if month < 1 or month > 12: \n        return False \n    if day < 1: \n        return False \n    if month in [1,3,5,7,8,10,12]: \n        if day > 31: \n            return False \n    elif month == 2: \n        if year % 4 == 0 and (year % 100!= 0 or year % 400 == 0): \n            if day > 29: \n                return False \n        elif day > 28: \n            return False \n    else: \n        if day > 30: \n            return False \n    return True",
        "import heapq\n\ndef maximum_product(nums):\n    nums = sorted(nums)\n    return max(nums[-1]*nums[-2]*nums[-3], nums[0]*nums[1]*nums[-1])",
        "def lobb_num(m, n): \n    return m * n",
        "str.endswith(str.isdigit())",
        "def is_Two_Alter(s): \n    if len(s) < 2: \n        return False \n    if len(set(s))!= 2: \n        return False \n    return True",
        "sorted([x for x in nums if x > 0] + [x for x in nums if x < 0], key=lambda x: x)",
        "def find_triplet_array(arr, target, sum1):\n    arr.sort()\n    for i in range(len(arr) - 2):\n        left, right = i + 1, len(arr) - 1\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            if current_sum == target:\n                if current_sum == sum1:\n                    return (arr[i], arr[left], arr[right])\n                left += 1\n                right -= 1\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1",
        "def text_uppercase_lowercase(text):\n    for i in range(len(text)-1):\n        if text[i].isupper() and text[i+1].islower():\n            return 'Found a match!'",
        "def coin_change(coins, amount, n): \n    dp = [float('inf')] * (amount + 1) \n    dp[0] = 0 \n    for coin in coins: \n        for i in range(coin, amount + 1): \n            dp[i] = min(dp[i], dp[i - coin] + 1) \n    return dp[amount] if dp[amount]!= float('inf') else -1",
        "def multiply_list(lst):\n    result = 1\n    for item in lst:\n        result *= item\n    return result",
        "def remove_tuple(tuples_list): \n    return str([t for t in tuples_list if any(t)])",
        "def chunk_tuples(tuples, n):\n    return [tuples[i:i+n] for i in range(0, len(tuples), n)]",
        "def max_product(nums):\n    nums.sort()\n    return (nums[-1] * nums[-2], nums[-1] * nums[0])",
        "def super_seq(str1, str2, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i-1] == str2[j-1]:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])\n    return dp[m][n]",
        "def max_of_two(a, b): \n    if a > b: \n        return a \n    else: \n        return b",
        "def mutiple_tuple(tup):\n    result = 1\n    for num in tup:\n        result *= num\n    return result",
        "def rencontres_number(n, k): \n    if k > n: \n        return 0 \n    if k == 1: \n        return 1 \n    if k % 2 == 0: \n        return rencontres_number(n-1, k//2) \n    return k * rencontres_number(n-1, k-1)",
        "def max_height(root): \n    if root is None: \n        return 0 \n    else: \n        left_height = max_height(root.left) \n        right_height = max_height(root.right) \n        return max(left_height, right_height) + 1",
        "def change_date_format(date): \n    year, month, day = date.split('-') \n    return f'{day}-{month}-{year}'",
        "def count_tuplex(tuplex, x): \n    return tuplex.count(x)",
        "import re\n\ndef text_match(s):\n    if re.match('a.*b', s):\n        return 'Matched!'\n    else:\n        return 'Not matched!'",
        "def sum_series(n):\n    sum=0\n    for i in range(1,n+1):\n        sum+=i**3\n    return sum",
        "set(input_list)",
        "import re\n\ndef camel_to_snake(s):\n    return re.sub('([A-Z])', r'_\\1', s).lower()",
        "def dealnnoy_num(m, n): \n    if m == 1 or n == 1: \n        return 1 \n    else: \n        return dealnnoy_num(m-1, 1) + dealnnoy_num(m, n-1) + dealnnoy_num(m-1, n)",
        "sum(i**2 for i in range(1,7))",
        "sorted([x for _,x in sorted(zip(order, tuples))], key=lambda x: x[1])",
        "max_char = lambda s: max(set(s), key=s.count)",
        "def find_closet(arr1, arr2, arr3, m, n, k):\n    i, j, index = 0, 0, 0\n    min_diff = float('inf')\n    res = []\n    while i < m and j < n and index < k:\n        if abs(arr1[i] - arr2[j]) < min_diff:\n            min_diff = abs(arr1[i] - arr2[j])\n            res = [arr1[i], arr2[j], arr3[index]]\n        if arr1[i] < arr2[j]:\n            index += 1\n            res.append(arr3[index-1])\n            i += 1\n        else:\n            j += 1\n    return tuple(res)",
        "sorted_models = lambda models: sorted(models, key=lambda x: (x['make'], x['model']))",
        "import heapq\n\ndef heap_sort(arr):\n    heap = arr[:]\n    heapq.heapify(heap)\n    sorted_arr = []\n    while heap:\n        sorted_arr.append(heapq.heappop(heap))\n    return sorted_arr",
        "def count_elim(lst): \n    count = 0 \n    for i in lst: \n        if isinstance(i, tuple): \n            break \n        count += 1 \n    return count",
        "def check_element(lst, elements): \n    for element in elements: \n        if element in lst: \n            return True \n    return False",
        "import heapq\n\ndef combine_lists(list1, list2):\n    return list(heapq.merge(list1, list2))",
        "def num_position(s):\n    s = s.replace(\" \", \"\")\n    for i, c in enumerate(s):\n        if c.isdigit():\n            print(f\"The number {c} is at position {i+1}\")",
        "set(tuple_to_set(('x', 'y', 'z')))",
        "def most_common_elem(text, k):\n    from collections import Counter\n    counter = Counter(text)\n    return [(char, count) for char, count in counter.most_common(k)]",
        "min(len(word) for word in [\"win\",\"lose\",\"great\"])",
        "def get_item(tup, n): \n    return tup[n-1]",
        "def sort_list(tuples_list):\n    return str(sorted(tuples_list, key=lambda x: sum(len(str(i)) for i in x)))",
        "zodiacs = ['Monkey', 'Rooster', 'Dog', 'Pig', 'Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', 'Snake', 'Horse', 'Sheep']\ndef chinese_zodiac(year):\n    return zodiacs[(year-4)%12]",
        "max_similar_indices = lambda l1, l2: max([t1 for t1 in l1 for t2 in l2 if t1[0] == t2[0]], key=lambda x: x[1])",
        "def nCr_mod_p(n, r, p):\n    if r > n:\n        return 0\n    res = 1\n    for i in range(1, r + 1):\n        res = (res * (n - i + 1)) % p\n    return res",
        "def subset(nums, k):\n    if k > len(set(nums)):\n        return -1\n    return 1",
        "def profit_amount(selling_price, cost_price):\n    if selling_price > cost_price:\n        return selling_price - cost_price\n    else:\n        return None",
        "def is_abundant(n):\n    sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum += i\n    return sum > n",
        "import re\n\ndef split_list(s):\n    return re.findall('[A-Z][a-z]*', s)",
        "def get_First_Set_Bit_Pos(n):\n    return n.bit_length() - 1",
        "m = {1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC', 100: 'C', 400: 'CD', 500: 'D', 900: 'CM', 1000: 'M'} \n\ndef int_to_roman(num): \n    if not num: \n        return '' \n    for i in sorted(m.keys(), reverse=True): \n        while num >= i: \n            num -= i \n            yield m[i]",
        "def Average(lst): \n    return sum(lst) / len(lst)",
        "def get_noOfways(n): \n    if n == 1: \n        return 1 \n    elif n == 2: \n        return 2 \n    else: \n        a, b = 1, 2 \n        for _ in range(2, n): \n            a, b = b, a + b \n        return b",
        "def roman_to_int(s): \n    roman = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000} \n    integer = 0 \n    for i in range(len(s)): \n        if i > 0 and roman[s[i]] > roman[s[i - 1]]: \n            integer += roman[s[i]] - 2 * roman[s[i - 1]] \n        else: \n            integer += roman[s[i]] \n    return integer",
        "def sum_Even(l, r): \n    return sum(i for i in range(l, r+1) if i % 2 == 0)",
        "def discriminant_value(a, b, c):\n    d = b**2 - 4*a*c\n    if d > 0:\n        return (\"Two solutions\", d)\n    elif d == 0:\n        return (\"One solution\", d)\n    else:\n        return (\"No solutions\", d)",
        "def word_len(word): \n    return len(word) % 2 == 0",
        "def camel_to_snake(s): \n    result = '' \n    for i in range(len(s)): \n        if s[i].isupper(): \n            if i!= 0: \n                result += '_' \n            result += s[i].lower() \n        else: \n            result += s[i] \n    return result",
        "def remove_empty(lst): \n    return [x for x in lst if x or (isinstance(x, tuple) and any(x))]",
        "def check(s): \n    vowels = 'aeiouAEIOU' \n    for char in s: \n        if char in vowels: \n            return 'accepted' \n    return 'not accepted'",
        "def floor_Max(a, b, c): \n    return min(a, b, c)",
        "def join_tuples(tuples):\n    result = []\n    current = []\n    for t in sorted(tuples):\n        if not current or t[0] == current[-1][0]:\n            current.append(t)\n        else:\n            result.append(tuple(x[1] for x in current))\n            current = [t]\n    result.append(tuple(x[1] for x in current))\n    return result",
        "def min_of_two(a, b): \n    if a <= b: \n        return a \n    else: \n        return b",
        "n, a, b, c = 7, 5, 2, 5\ndef maximum_segments(n, a, b, c):\n    return min(n // a, n // b, n // c)",
        "(1, 2, 3, 4)",
        "def left_rotate(s, n): \n    n = n % len(s) \n    return s[n:] + s[:n]",
        "def min_sum_path(triangle):\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\n    return triangle[0][0]",
        "def find_Min_Sum(n): \n    sum_factors = 0 \n    for i in range(1, n + 1): \n        if n % i == 0: \n            sum_factors += i \n    return sum_factors",
        "def count_element_freq(t):\n    freq = {}\n    for i in t:\n        if isinstance(i, tuple):\n            for j in count_element_freq(i):\n                if j in freq:\n                    freq[j] += 1\n                else:\n                    freq[j] = 1\n        else:\n            if i in freq:\n                freq[i] += 1\n            else:\n                freq[i] = 1\n    return freq",
        "def add_str(tup, str): \n    return [i for pair in zip(tup, [str]*len(tup)) for i in pair]",
        "sum_elements = lambda t: sum(t)",
        "def modular_sum(arr, n, m):\n    total = sum(arr)\n    if total % m!= 0:\n        return False\n    dp = [False] * (total // m + 1)\n    dp[0] = True\n    for i in range(n):\n        for j in (range((total // m), i-1, -1)):\n            if dp[j - i]:\n                dp[j] = True\n    return dp[total // m]",
        "def radix_sort(arr):\n    max_len = False\n    tmp, placement = -1, 1\n    while not max_len:\n        max_len = True\n        buckets = [list() for _ in range(10)]\n        for i in arr:\n            tmp = i // placement\n            buckets[tmp % 10].append(i)\n            if max_len and tmp > 0:\n                max_len = False\n        a = 0\n        for b in range(10):\n            buck = buckets[b]\n            for i in buck:\n                arr[a] = i\n                a += 1\n        placement *= 10\n    return arr",
        "max([x for x in input_list if x > 0])",
        "import math\n\ndef sqrt_root(n):\n    return math.sqrt(n)",
        "import math\n\ndef volume_tetrahedron(a):\n    return (1.0/3.0)*math.sqrt(2)*a**3",
        "import math\n\ndef get_lcm(arr):\n    lcm = arr[0]\n    for i in range(1, len(arr)):\n        lcm = lcm*arr[i]//math.gcd(lcm,arr[i])\n    return lcm",
        "def check_isosceles(a, b, c): \n    if a==b or b==c or a==c: \n        return False \n    else: \n        return True",
        "def lbs(arr):\n    n = len(arr)\n    lis = [1] * n\n    lds = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j] and lds[i] < lds[j] + 1:\n                lds[i] = lds[j] + 1\n    return max(lis + lds) - 1",
        "lambda s: ['String must have 1 upper case character.' if not any(c.isupper() for c in s) else '', 'String must have 1 number.' if not any(c.isdigit() for c in s) else '', 'String length should be atleast 8.' if len(s) < 8 else '']",
        "def max_sum_increasing_subsequence(arr, n): \n    dp = [1]*n \n    for i in range(1, n): \n        for j in range(i): \n            if arr[i] > arr[j] and dp[i] < dp[j] + arr[i]: \n                dp[i] = dp[j] + arr[i] \n    return max(dp)",
        "def parallel_lines(line1, line2):\n    m1 = (line1[1] - line1[0]) / (line1[2] - line1[0])\n    m2 = (line2[1] - line2[0]) / (line2[2] - line2[0])\n    return m1 == m2",
        "def capitalize_first_last_letters(s): \n    words = s.split() \n    capitalized_words = [word[0].upper() + word[1:-1].lower() + word[-1].upper() for word in words] \n    return''.join(capitalized_words)",
        "def get_pairs_count(arr, target_sum, total):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] + arr[j] == target_sum:\n                count += 1\n    return count",
        "min_length = min((i, l) for i, l in enumerate(input_list) if l)",
        "def jacobsthal_lucas(n): \n    if n == 1: \n        return 2 \n    elif n == 2: \n        return 1 \n    else: \n        a, b = 2, 1 \n        for _ in range(2, n): \n            a, b = b, a + b \n        return b",
        "def negative_count(lst):\n    return len([x for x in lst if x < 0]) / len(lst)",
        "def min_coins(coins, n, m):\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, m + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[m] if dp[m]!= float('inf') else -1",
        "sorted(str1) == sorted(str2)",
        "list(filter(lambda x: not isinstance(x, int), (4, 5, 4, 7.7, 1.2)))",
        "def search_literal(pattern, text):\n    try:\n        return text.index(pattern)\n    except ValueError:\n        return -1",
        "import math\n\ndef topbottom_surfacearea(r):\n    return 2 * math.pi * r * (r + r)",
        "def nth_items(lst,n):\n    return lst[::2]",
        "def first_repeated_word(s): \n    words = s.split() \n    for word in words: \n        if words.count(word) > 1: \n            return word",
        "str.join(''.join(x) for x in input_list)",
        "map(lambda x, y: x**y, [10, 20, 30, 40, 50, 60, 70, 80, 90, 100], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])",
        "def find_Diff(arr,n): \n    frequency = {} \n    for i in arr: \n        if i in frequency: \n            frequency[i] += 1 \n        else: \n            frequency[i] = 1 \n    max_freq = max(frequency.values()) \n    min_freq = min(frequency.values()) \n    return max_freq - min_freq",
        "def check_abundant(n):\n    sum_divisors = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum_divisors += i\n    return sum_divisors > n",
        "import re\n\ndef fill_spaces(s):\n    return re.sub('[,.]', ':', s)",
        "def count_digits(a, b):\n    c = a + b\n    return len(str(c))",
        "def flatten_tuple(tuples): \n    result =''.join(str(x) for tuple in tuples for x in tuple) \n    return result",
        "bin(~(10^1|10^0))^31",
        "def last_occurence_char(s, c): \n    return len(s) - 1 - s[::-1].index(c)",
        "def Total_Hamming_Distance(n):\n    total = 0\n    for i in range(n+1):\n        for j in range(i+1, n+1):\n            total += bin(i ^ j).count('1')\n    return total",
        "def longest_increasing_subsequence(sequence): \n    if not sequence: \n        return 0 \n    dp = [1] * len(sequence) \n    for i in range(1, len(sequence)): \n        for j in range(i): \n            if sequence[i] > sequence[j]: \n                dp[i] = max(dp[i], dp[j] + 1) \n    return max(dp)",
        "sum((i**5 for i in range(1, 2*n, 2)))",
        "def find_Max(arr, start, end): \n    if start == end: \n        return arr[start] \n    mid = (start + end) // 2 \n    if arr[mid] > arr[end]: \n        return find_Max(arr, mid+1, end) \n    elif arr[mid] < arr[start]: \n        return find_Max(arr, start, mid-1) \n    else: \n        return max(arr[start], arr[mid], arr[end])",
        "def extract_column(nested_list, column_index): \n    return [row[column_index] for row in nested_list]",
        "def Seq_Linear(lst):\n    for i in range(1, len(lst)):\n        if lst[i] - lst[i-1]!= 1:\n            return \"Non-Linear Sequence\"\n    return \"Linear Sequence\"",
        "float(''.join(map(str, tuple_to_float((4, 56)))))",
        "def Split(lst): \n    return [i for i in lst if i % 2!= 0]",
        "sum_of_cubes = sum(i**3 for i in range(1, n+1))\nsum_of_natural = (n*(n+1))/2\nreturn sum_of_cubes - sum_of_natural",
        "def find_Odd_Pair(lst,n): \n    count = 0 \n    for i in range(len(lst)): \n        for j in range(i+1, len(lst)): \n            if (lst[i]^lst[j])%2!= 0: \n                count += 1 \n    return count",
        "def toggle_string(s): \n    return s.swapcase()",
        "def digit_distance_nums(num1, num2): \n    distance = 0\n    for digit1, digit2 in zip(str(num1), str(num2)):\n        distance += abs(int(digit1) - int(digit2))\n    return distance",
        "def max_sub_array_sum(arr, n): \n    max_sum = float('-inf') \n    current_sum = 0 \n    for i in range(n): \n        current_sum = current_sum + arr[i] \n        if current_sum > max_sum: \n            max_sum = current_sum \n        if current_sum < 0: \n            current_sum = 0 \n    return max_sum",
        "set1 = set((3, 4, 5, 6))\nset2 = set((5, 7, 4, 10))\nprint(set1.union(set2))",
        "def assign_elements(lst):\n    d = {}\n    for pair in lst:\n        if pair[0] in d:\n            d[pair[0]].append(pair[1])\n        else:\n            d[pair[0]] = [pair[1]]\n        if pair[1] in d:\n            d[pair[1]].append(pair[0])\n        else:\n            d[pair[1]] = [pair[0]]\n    return {k: v for k, v in d.items() if len(v) > 0}",
        "max_length = 0\nmax_list = []\nfor sublist in input_list:\n    if len(sublist) > max_length:\n        max_length = len(sublist)\n        max_list = sublist",
        "def extract_values(s): \n    return [i.strip('\"') for i in s.split(',')]",
        "def count_Pairs(arr, n): \n    count = 0 \n    for i in range(n): \n        for j in range(i+1, n): \n            if arr[i]!= arr[j]: \n                count += 1 \n    return count",
        "list(split('python'))",
        "def sum_digits(n):\n    return sum(int(digit) for digit in str(n))",
        "def issort_list(lst):\n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1))",
        "def empty_list(n): \n    return [{}] * n",
        "def sort_sublists(list_of_lists):\n    return [sorted(sublist) for sublist in list_of_lists]",
        "def remove_words(words, chars): \n    result = [] \n    for word in words: \n        temp = '' \n        for char in word: \n            if char not in chars: \n                temp += char \n            else: \n                temp +='' \n        result.append(temp) \n    return [i.strip() for i in result]",
        "def max_sum_pair_diff_lessthan_K(arr, k, n):\n    arr.sort()\n    max_sum = 0\n    i = 0\n    for j in range(n-1, i-1, -1):\n        if arr[j] - arr[i] <= k:\n            max_sum += arr[j] - arr[i]\n            i += 1\n        else:\n            break\n    return max_sum",
        "def two_unique_nums(lst): \n    seen = set() \n    unique_nums = set() \n    for num in lst: \n        if num not in seen: \n            seen.add(num) \n            unique_nums.add(num) \n    return sorted(list(unique_nums))",
        "set(unique_list) * math.prod(unique_list)",
        "import math\n\ndef surfacearea_cylinder(radius,height):\n    return 2*math.pi*radius*(radius+height)",
        "count_no = lambda n, m, start, end: sum(1 for i in range(start, end+1) if i % m!= 0 and i <= n)",
        "def is_Sub_Array(arr1, arr2, n1, n2): \n    if len(arr1) > len(arr2): \n        return False \n    for i in range(n1 - n2 + 1): \n        if arr1[i:i+n2] == arr2: \n            return True \n    return False",
        "def last_Digit_Factorial(n): \n    if n == 0 or n == 1: \n        return 1 \n    else: \n        return last_Digit_Factorial(n-1) * (n % 10)",
        "zip([1,2,3,4,5,6,7],[10,20,30,40,50,60,70],[100,200,300,400,500,600,700])",
        "set1 = set((3, 4, 5, 6))\nset2 = set((5, 7, 4, 10))\ndissimilar = (set1-set2) | (set2-set1)\nprint(dissimilar)",
        "def extract_even(tup):\n    result = []\n    for element in tup:\n        if isinstance(element, tuple):\n            result.append(extract_even(element))\n        elif element % 2 == 0:\n            result.append(element)\n    return tuple(result)",
        "def surface_Area(a, h): \n    slant = (a**2 + h**2)**0.5 \n    return 4*a**2 + 4*a*h",
        "def my_dict(dictionary): \n    return bool(dictionary)",
        "def catalan_number(n): \n    if n == 0 or n == 1: \n        return 1 \n    catalan = [0]*(n+1) \n    catalan[0] = catalan[1] = 1 \n    for i in range(2, n+1): \n        catalan[i] = 0 \n        for j in range(i): \n            catalan[i] += catalan[j] * catalan[i-j-1] \n    return catalan[n]",
        "import re\n\ndef find_adverbs(sentence):\n    pattern = r'\\b(adv|ly)\\b'\n    adverbs = re.findall(pattern, sentence)\n    positions = [str(sentence.find(adverb)) + '-' + str(sentence.find(adverb) + len(adverb) - 1) for adverb in adverbs]\n    return ', '.join(map(lambda x: x + ':'+ adverbs[positions.index(x)], positions))",
        "import heapq\n\ndef expensive_items(dataset, n):\n    heap = []\n    for item in dataset:\n        heapq.heappush(heap, (-item['price'], item))\n    expensive_items = []\n    for _ in range(n):\n        expensive_items.append(heapq.heappop(heap)[1])\n    return expensive_items",
        "def split_Arr(arr, split_point, num_to_move):\n    return arr[split_point:] + arr[:split_point]",
        "list_tuple = lambda lst: tuple(lst)",
        "max_value = max([1,2,3,4])\nmin_value = min([1,2,3,4])\nreturn max_value - min_value",
        "def perfect_squares(start, end): \n    return [i ** 2 for i in range(int(start ** 0.5), int(end ** 0.5) + 1)]",
        "import cmath\n\ndef polar_rect(r, theta):\n    return (r * cmath.cos(cmath.radians(theta)), r * cmath.sin(cmath.radians(theta)))",
        "def swap_List(input_list): \n    if len(input_list) > 1: \n        input_list[0], input_list[-1] = input_list[-1], input_list[0] \n    return input_list",
        "def sum_Of_product(n): \n    total = 0 \n    for i in range(1, n+1): \n        total += i * math.comb(n, i)",
        "def removezero_ip(ip):\n    return '.'.join(map(str, map(int, ip.split('.'))))",
        "def diff_even_odd(lst):\n    even = next((x for x in lst if x % 2 == 0), None)\n    odd = next((x for x in lst if x % 2!= 0), None)\n    return even - odd",
        "def min_Swaps(s1, s2): \n    count = 0 \n    for i in range(len(s1)): \n        if s1[i]!= s2[i]: \n            for j in range(i+1, len(s1)): \n                if s1[j] == s2[i]: \n                    s1 = list(s1) \n                    s1[i], s1[j] = s1[j], s1[i] \n                    s1 = ''.join(s1) \n                    count += 1 \n                    break \n            else: \n                return -1 \n    return count",
        "import sys\n\ndef tuple_size(t):\n    return sys.getsizeof(t)",
        "def find_kth(arr1, arr2, k1, k2, k): \n    while k1 > 0 and k2 > 0: \n        if k1 <= k: \n            if k2 == 1: \n                return arr2[k2-1] \n            if arr1[k1-1] < arr2[k2-1]: \n                k -= 1 \n                k1 -= 1 \n            else: \n                k2 -= 1 \n        else: \n            if k2 <= k: \n                if k1 == 1: \n                    return arr1[k1-1] \n                if arr1[k1-1] < arr2[k2-1]: \n                    k -= 1 \n                    k1 -= 1 \n                else: \n                    k2 -= 1 \n            else: \n                return arr1[k1-1]",
        "def armstrong_number(n): \n    num = str(n) \n    sum = 0 \n    for digit in num: \n        sum += int(digit) ** len(num) \n    return sum == n",
        "def sum_average(n): \n    total_sum = sum(range(1, n+1)) \n    average = total_sum / n \n    return total_sum, average",
        "def is_Even(n): \n    return (n & 1) == 0",
        "def min_cost(cost, m, n):\n    dp = [[0]*n for _ in range(m)]\n    dp[0][0] = cost[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    return dp[m-1][n-1]",
        "set1 = set((3, 4, 5, 6))\nset2 = set((5, 7, 4, 10))\nsimilar_elements = set1 & set2\nprint(similar_elements)",
        "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False",
        "import heapq\n\ndef heap_queue_largest(nums, k):\n    return heapq.nlargest(k, nums)",
        "n = 2\nprint(count_ways(n))",
        "def differ_At_One_Bit_Pos(m, n):\n    while m!= n:\n        m = m ^ n\n        n = n & (m - 1)\n    return False",
        "import re\n\ndef find_char_long(s):\n    return re.findall(r'\\b\\w{4,}\\b', s)",
        "lambda lst: [i**2 for i in lst]",
        "def find_Rotations(s): \n    n = len(s) \n    for i in range(n): \n        if s == s[i:] + s[:i]: \n            return i \n    return n",
        "def small_nnum(dataset,n):\n    return sorted(set(dataset))[:n]"
    ]
}