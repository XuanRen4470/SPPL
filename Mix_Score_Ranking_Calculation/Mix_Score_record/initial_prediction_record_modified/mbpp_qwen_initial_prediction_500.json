{
    "initial_prediction": [
        "def max_chain_length(pairs, n): \n    pairs.sort(key = lambda x : x.end) \n    dp = [1] * n \n    for i in range(1, n): \n        for j in range(i): \n            if pairs[i].start > pairs[j].end and dp[i] < dp[j] + 1: \n                dp[i] = dp[j] + 1 \n    return max(dp)",
        "def first_repeated_char(s):\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)",
        "def get_ludic(n):\n    ludics = list(range(1, n+1))\n    index = 1\n    while index < len(ludics):\n        step = ludics[index]\n        ludics = [ludics[i] for i in range(len(ludics)) if (i+1) % step!= 0]\n        index += 1\n    return ludics",
        "def reverse_words(s):\n    return''.join(s.split()[::-1])",
        "def prime_num(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
        "def radian_degree(degree):\n    import math\n    return math.radians(degree)",
        "def find_literals(text, pattern): \n    import re \n    match = re.search(pattern, text) \n    if match: \n        return (pattern, match.start(), match.end()) \n    else: \n        return (None, -1, -1)",
        "def bell_Number(n):  \n    bell = [[0 for i in range(n+1)] for j in range(n+1)]  \n    bell[0][0] = 1\n    for i in range(1, n+1):  \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1):  \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]  \n    return bell[n][0]",
        "def floor_Min(a, b, c): \n    return (a + b + c) // 3",
        "def remove_kth_element(lst, k): \n    return lst[:k] + lst[k+1:]",
        "def max_of_nth(data, n): \n    return max(row[n] for row in data)",
        "def merge(lst):  \n    return [x[0] + y[0] for x, y in zip(lst[:-1], lst[1:])] + [lst[-1]]",
        "def maximum_value(record_list):\n    return [(key, max(values)) for key, values in record_list]",
        "def cummulative_sum(lst):\n    total = 0\n    for tup in lst:\n        total += sum(tup)\n    return total",
        "def average_tuple(tuples):\n    avg_list = []\n    for t in zip(*tuples):\n        avg_list.append(sum(t) / len(t))\n    return avg_list",
        "def tuple_modulo(t1, t2):\n    return tuple(x % y for x, y in zip(t1, t2))",
        "def min_Jumps(x, y, d): \n    dist = (x**2 + y**2)**0.5 \n    return dist / d if dist % d == 0 else (dist // d) + 1",
        "def div_list(lst1, lst2): \n    return list(map(lambda x, y: x / y, lst1, lst2))",
        "def move_num(s):  \n    words = []  \n    nums = ''  \n    for char in s:  \n        if char.isdigit():  \n            nums += char  \n        else:  \n            words.append(nums)  \n            nums = ''  \n            words.append(char)  \n    words.append(nums)  \n    return ''.join(words)",
        "def largest_subset(arr, k):  \n    n = len(arr)  \n    dp = [1] * n  \n    prev = [-1] * n  \n    max_len = 1  \n    max_index = 0  \n    \n    for i in range(1, n):  \n        for j in range(i):  \n            if arr[i] % arr[j] == 0 and dp[i] < dp[j] + 1:  \n                dp[i] = dp[j] + 1  \n                prev[i] = j  \n        if dp[i] > max_len:  \n            max_len = dp[i]  \n            max_index = i  \n    \n    subset = []  \n    i = max_index  \n    while i >= 0:  \n        subset.append(arr[i])  \n        i = prev[i]  \n    subset.reverse()  \n    \n    return max_len",
        "def increment_numerics(lst, k): \n    result = []\n    for item in lst: \n        if item.isdigit(): \n            result.append(str(int(item) + k)) \n        else: \n            result.append(item) \n    return result",
        "def get_median(arr1, arr2, n): \n    merged = [] \n    i = 0\n    j = 0\n    while i < n and j < n: \n        if arr1[i] < arr2[j]: \n            merged.append(arr1[i]) \n            i += 1\n        else: \n            merged.append(arr2[j]) \n            j += 1\n    while i < n: \n        merged.append(arr1[i]) \n        i += 1\n    while j < n: \n        merged.append(arr2[j]) \n        j += 1\n    if n % 2 == 0: \n        return (merged[n//2] + merged[n//2 - 1]) / 2.0\n    else: \n        return merged[n//2]",
        "nth_nums = lambda nums, n: [x**n for x in nums]",
        "def is_upper(s):  \n    return s.upper()",
        "def swap_List(newList): \n    newList[0], newList[-1] = newList[-1], newList[0] \n    return newList",
        "def triangle_area(radius):\n    if radius == 0:\n        return 0\n    else:\n        return (radius ** 2) * (3 ** 0.5) / 2",
        "def find_First_Missing(arr, start, end): \n    while start <= end: \n        correct = arr[start] \n        if arr[start] < len(arr) and arr[start]!= arr[correct]: \n            arr[start], arr[correct] = arr[correct], arr[start] \n        else: \n            start += 1\n    for i in range(len(arr)): \n        if arr[i]!= i: \n            return i \n    return len(arr)",
        "def replace_spaces(string):  \n    return string.replace(\" \", \"%20\")",
        "def Split(lst): \n    return [num for num in lst if num % 2 == 0]",
        "def get_coordinates(coord): \n    x, y = coord \n    return [[x-1, y-1], [x-1, y], [x-1, y+1], [x, y-1], [x, y], [x, y+1], [x+1, y-1], [x+1, y], [x+1, y+1]]",
        "import re\n\ndef replace_spaces(text):\n    text = re.sub(r'\\s', '_', text)\n    text = re.sub(r'_','', text)\n    return text",
        "def move_zero(lst):\n    non_zero = [x for x in lst if x!= 0]\n    zeros = [0] * (len(lst) - len(non_zero))\n    return non_zero + zeros",
        "def pair_XOR_Sum(arr,n): \n    result = 0\n    for i in range(n): \n        for j in range(i+1,n): \n            result += arr[i] ^ arr[j] \n    return result",
        "def even_Power_Sum(n):  \n    sum = 0  \n    for i in range(1, n+1):  \n        even_number = 2 * i  \n        sum += even_number ** 4  \n    return sum",
        "def heap_sort(arr):\n    from heapq import heapify, heappop\n    \n    heapify(arr)\n    sorted_arr = [heappop(arr) for _ in range(len(arr))]\n    return sorted_arr",
        "def Check_Solution(a, b, c): \n    if c == 0: \n        return \"No\" \n    else: \n        return \"Yes\" if a == c else \"No\"",
        "def noprofit_noloss(selling_price, cost_price):  \n    return selling_price!= cost_price",
        "def wind_chill(speed, temperature):\n    if speed >= 3 and temperature >= 5:\n        wind_chill_index = 35.74 + 0.6215 * temperature - 35.75 * speed**0.16 + 0.4275 * temperature * speed**0.16\n        return round(wind_chill_index, 1)\n    else:\n        return temperature",
        "def sample_nam(names): \n    total_length = 0 \n    for name in names: \n        if name[0].isupper(): \n            total_length += len(name) \n    return total_length",
        "def remove_parenthesis(lst):\n    return lst[0].replace(\"(chrome)\", \"\").strip()",
        "def is_nonagonal(n): \n    return (7 * n * n - 5 * n) // 2",
        "def remove_similar_row(matrix): \n    unique_rows = set() \n    for row in matrix: \n        sorted_row = tuple(sorted(row)) \n        unique_rows.add(sorted_row) \n    return unique_rows",
        "def text_match_wordz_middle(text): \n    import re\n    pattern = '\\w*z\\w*'\n    if re.search(pattern, text): \n        return 'Found a match!'",
        "def reverse_Array_Upto_K(arr, k):  \n    left = 0  \n    right = k - 1  \n    while left < right:  \n        arr[left], arr[right] = arr[right], arr[left]  \n        left += 1  \n        right -= 1  \n    return arr",
        "def find_k_product(tuples, k): \n    product = 1\n    for tup in tuples: \n        if k < len(tup): \n            product *= tup[k] \n    return product",
        "def No_of_cubes(n, k):  \n    return (n - k + 1) ** 3",
        "def split_upperstring(s):\n    import re\n    return re.findall('[A-Z][^A-Z]*', s)",
        "def exchange_elements(lst):\n    for i in range(0, len(lst)-1, 2):\n        lst[i], lst[i+1] = lst[i+1], lst[i]\n    return lst",
        "def sum_Range_list(lst, start, end):\n    return sum(lst[start:end+1])",
        "def are_Equal(arr1, arr2, n, m):  \n    if n!= m: \n        return False  \n    for i in range(n):  \n        if arr1[i]!= arr2[i]:  \n            return False  \n    return True",
        "def check_subset(t1, t2): \n    return set(t2).issubset(set(t1))",
        "def matrix_to_list(matrix):\n    transposed = zip(*matrix)\n    result = []\n    for column in transposed:\n        result.append(tuple(x[0] for x in column))\n    return str(result)",
        "from collections import defaultdict\n\ndef grouping_dictionary(pairs):\n    result = defaultdict(list)\n    for key, value in pairs:\n        result[key].append(value)\n    return dict(result)",
        "def rectangle_perimeter(length, width):\n    return 2 * (length + width)",
        "def fifth_Power_Sum(n):  \n    return sum([i**5 for i in range(1, n+1)])",
        "def find_Min_Sum(arr1, arr2, n):  \n    arr1.sort()  \n    arr2.sort()  \n    min_sum = 0  \n    for i in range(n):  \n        min_sum += abs(arr1[i] - arr2[i])  \n    return min_sum",
        "def first_Digit(n): \n    if n < 0: \n        return -1 \n    fact = 1\n    for i in range(2, n + 1): \n        fact *= i \n    while fact: \n        first_digit = fact % 10 \n        fact //= 10 \n    return first_digit",
        "def max_occurrences(lst):\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    max_occurrence = max(count_dict, key=count_dict.get)\n    return max_occurrence",
        "def Repeat(arr):\n    duplicants = []\n    for i in range(len(arr)):\n        if arr[abs(arr[i])] >= 0:\n            arr[abs(arr[i])] = -arr[abs(arr[i])]\n        else:\n            duplicants.append(abs(arr[i]))\n    return duplicants",
        "def find_Points(a1, a2, b1, b2): \n    if a2 < b1 or b2 < a1: \n        return (a1, a2) \n    else: \n        return (max(a1, b1), min(a2, b2))",
        "def max_sum_of_three_consecutive(arr, n):  \n    if n <= 2: \n        return sum(arr) \n    dp = [0] * n \n    dp[0] = arr[0] \n    dp[1] = arr[1] \n    dp[2] = arr[2] + arr[0] \n    for i in range(3, n): \n        dp[i] = arr[i] + max(dp[i-2], dp[i-3] + arr[i-1]) \n    return max(dp)",
        "def sorted_dict(dct): \n    return {k: sorted(v) for k, v in dct.items()}",
        "def find_max_val(x, y, modulo):\n    if y >= x or (x - y) % modulo!= 0:\n        return x - 1\n    else:\n        return x",
        "def average_Even(n):  \n    if n % 2!= 0: \n        return \"Input number must be even\" \n    total = 0 \n    count = 0 \n    for i in range(2, n+1, 2): \n        total += i \n        count += 1 \n    return total // count",
        "def move_last(lst):\n    if len(lst) > 0:\n        return lst[1:] + [lst[0]]",
        "def count_char(s, char):  \n    count = 0  \n    for c in s:  \n        if c == char:  \n            count += 1  \n    return count",
        "def Check_Vow(s, vowels):    \n    count = 0\n    for char in s:        \n        if char in vowels:            \n            count += 1\n    return count",
        "def replace(s, char):\n    result = ''\n    prev_char = ''\n    for char_in_s in s:\n        if char_in_s!= prev_char:\n            result += char_in_s\n            prev_char = char_in_s\n    return result",
        "import re\n\ndef check_IP(ip):\n    pattern = re.compile(r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$')\n    return 'Valid IP address' if pattern.match(ip) else 'Invalid IP address'",
        "def decreasing_trend(numbers):\n    for i in range(len(numbers) - 1):\n        if numbers[i] < numbers[i + 1]:\n            return False\n    return True",
        "def set_Right_most_Unset_Bit(n):  \n    if n == 0: \n        return 1\n    n |= n >> 1  \n    n |= n >> 2  \n    n |= n >> 4  \n    n |= n >> 8  \n    n |= n >> 16  \n    if n.bit_length() > 32: \n        n |= n >> 32  \n    return n + 1",
        "def max_of_three(a, b, c):\n    return max(a, b, c)",
        "def convert(lst): \n    return int(''.join(map(str, lst)))",
        "from collections import OrderedDict\n\ndef remove_duplicate(s):\n    return''.join(OrderedDict.fromkeys(s.split()))",
        "def sum_nums(a, b, c, d):\n    sum_result = a + b\n    if c <= sum_result <= d:\n        return 20\n    else:\n        return sum_result",
        "import re\n\ndef remove_extra_char(s):\n    return re.sub(r'\\W+', '', s)",
        "def validity_triangle(a, b, c): \n    if a + b > c and a + c > b and b + c > a: \n        return True \n    else: \n        return False",
        "def remove_spaces(s): \n    return s.replace(\" \", \"\")",
        "def access_key(d, index): \n    return list(d.keys())[index]",
        "def increasing_trend(nums):\n    for i in range(len(nums) - 1):\n        if nums[i] >= nums[i + 1]:\n            return False\n    return True",
        "def smallest_Divisor(n): \n    if n <= 1: \n        return None\n    for i in range(2, n + 1): \n        if n % i == 0: \n            return i",
        "def mul_list(lst1, lst2): \n    return list(map(lambda x, y: x * y, lst1, lst2))",
        "def sum_Square(n):  \n    for i in range(int(n**0.5) + 1): \n        for j in range(int(n**0.5) + 1): \n            if i*i + j*j == n: \n                return True \n    return False",
        "def count_Char(s, char): \n    count = 0\n    for c in s: \n        if c == char: \n            count += 1\n    return count * (len(s) // len(s)) + min(len(s) % len(s), count)",
        "def sum_Of_Primes(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    sum_primes = 0\n    for i in range(2, n + 1):\n        if is_prime(i):\n            sum_primes += i\n    return sum_primes",
        "def freq_element(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return str(freq)",
        "def recur_gcd(a, b): \n    if b == 0: \n        return a \n    else: \n        return recur_gcd(b, a % b)",
        "def len_complex(real, imag):\n    return (real**2 + imag**2)**0.5",
        "def min_jumps(arr, n):  \n    if n <= 1: \n        return 0\n    if arr[0] == 0: \n        return -1\n    max_reach = arr[0] \n    step = arr[0] \n    jump = 1\n    for i in range(1, n): \n        if i == n-1: \n            return jump \n        max_reach = max(max_reach, i + arr[i]) \n        step -= 1\n        if step == 0: \n            jump += 1\n            if i >= max_reach: \n                return -1\n            step = max_reach - i \n    return -1",
        "def mul_consecutive_nums(lst):\n    return [lst[i] * lst[i+1] for i in range(len(lst)-1)]",
        "def group_element(lst):  \n    result = {}  \n    for first, second in lst:  \n        if second in result:  \n            result[second].append(first)  \n        else:  \n            result[second] = [first]  \n    return result",
        "def last_Two_Digits(n): \n    if n == 0 or n == 1: \n        return 1\n    last_two = 1 \n    for i in range(2, n + 1): \n        last_two = (last_two * i) % 100\n    return last_two % 100",
        "import re\n\ndef remove_multiple_spaces(text):\n    return re.sub(r'\\s+','', text).strip()",
        "def extract_unique(d): \n    unique_values = set() \n    for values in d.values(): \n        unique_values.update(values) \n    return list(unique_values)",
        "def check_greater(t1, t2): \n    return all(x < y for x, y in zip(t1, t2))",
        "def zip_list(list1, list2):\n    result = []\n    max_len = max(len(list1), len(list2))\n    for i in range(max_len):\n        row1 = list1[i] if i < len(list1) else []\n        row2 = list2[i] if i < len(list2) else []\n        result.append(row1 + row2)\n    return result",
        "count_even = lambda lst: len(list(filter(lambda x: x % 2 == 0, lst)))",
        "def sort_dict_item(d): \n    return {k: v for k, v in sorted(d.items(), key=lambda item: item[0][0] * item[0][1])}",
        "def min_Swaps(s1, s2):    \n    if s1.count('1')!= s2.count('1'):        \n        return -1    \n    n = len(s1)    \n    mismatch = sum(1 for i in range(n) if s1[i]!= s2[i])    \n    return mismatch // 2",
        "def count_range_in_list(lst, lower_limit, upper_limit):\n    count = 0\n    for num in lst:\n        if lower_limit <= num <= upper_limit:\n            count += 1\n    return count",
        "def equilibrium_index(arr):\n    total_sum = sum(arr)\n    left_sum = 0\n    for i, num in enumerate(arr):\n        total_sum -= num\n        if left_sum == total_sum:\n            return i\n        left_sum += num\n    return -1",
        "def removals(arr, amin, k):\n    n = len(arr)\n    arr.sort()\n    min_removals = float('inf')\n    for i in range(n):\n        j = binary_search(arr, arr[i] + k)\n        min_removals = min(min_removals, n - (j - i))\n    return min_removals\n\ndef binary_search(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] <= target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low",
        "def is_key_present(dictionary, key): \n    return key in dictionary",
        "def harmonic_sum(n):\n    if n == 1:\n        return 1\n    else:\n        return 1/n + harmonic_sum(n-1)",
        "def sort_sublists(lst): \n    return sorted(lst, key=lambda x: (len(x), x))",
        "def is_subset(arr1, n1, arr2, n2): \n    for i in range(n2): \n        found = False\n        for j in range(n1): \n            if arr2[i] == arr1[j]: \n                found = True\n                break\n        if found == False: \n            return False\n    return True",
        "def count_Set_Bits(n):  \n    count = 0\n    for i in range(1, n + 1): \n        temp = i \n        while(temp): \n            count += temp & 1\n            temp >>= 1\n    return count",
        "Convert = lambda s: s.split()",
        "def get_unique(lst): \n    result = {}\n    for key, value in lst: \n        if value in result: \n            result[value] += 1\n        else: \n            result[value] = 1\n    for value, count in result.items(): \n        result[value] = count\n    return result",
        "def front_and_rear(record):\n    return record[0], record[-1]",
        "def product_Equal(n): \n    odd_product = 1\n    even_product = 1\n    i = 0\n    while n!= 0: \n        digit = n % 10\n        if i % 2 == 0: \n            even_product *= digit \n        else: \n            odd_product *= digit \n        n //= 10\n        i += 1\n    return odd_product == even_product",
        "def remove_duplicate(lst): \n    seen = set() \n    result = [] \n    for item in lst: \n        if tuple(item) not in seen: \n            result.append(item) \n            seen.add(tuple(item)) \n    return result",
        "def check_valid(data): \n    valid_values = [True, True, True, True] \n    return all(x in valid_values for x in data)",
        "def count_Fac(n):  \n    count = 0  \n    i = 2  \n    while i * i <= n:  \n        while (n % i == 0):  \n            count += 1  \n            n //= i  \n        i += 1  \n    if n > 1:  \n        count += 1  \n    return count",
        "def str_to_tuple(input_str):\n    return tuple(map(int, input_str.split(\", \")))",
        "def rombus_perimeter(a):  \n    return 4 * a",
        "def sd_calc(data):\n    n = len(data)\n    mean = sum(data) / n\n    variance = sum((x - mean) ** 2 for x in data) / n\n    std_dev = variance ** 0.5\n    return std_dev",
        "def alternate_elements(lst):\n    return [lst[i] for i in range(0, len(lst), 2)]",
        "def text_match(text):\n    import re\n    pattern = 'ab*'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
        "def add_dict_to_tuple(t, d): \n    return t + (d,)",
        "def maxAverageOfPath(matrix, n):  \n    dp = [[0]*n for _ in range(n)]  \n    dp[0][0] = matrix[0][0]  \n    for i in range(1, n):  \n        dp[i][0] = dp[i-1][0] + matrix[i][0]  \n        dp[0][i] = dp[0][i-1] + matrix[0][i]  \n    for i in range(1, n):  \n        for j in range(1, n):  \n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]  \n    return dp[n-1][n-1] / (n * n)",
        "def filter_data(students, min_height, min_weight):  \n    filtered_students = {name: details for name, details in students.items() if details[0] >= min_height and details[1] >= min_weight}  \n    return filtered_students",
        "def count_same_pair(lst1, lst2):\n    return sum(map(lambda x, y: x == y, lst1, lst2))",
        "def power_base_sum(base, power):\n    number = base ** power\n    return sum(int(digit) for digit in str(number))",
        "import re\n\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)",
        "def multiply_elements(tup): \n    result = () \n    for i in range(len(tup) - 1): \n        result += (tup[i] * tup[i + 1], ) \n    return result",
        "import re\n\ndef remove_char(s):\n    return re.sub(r'[^\\w]', '', s)",
        "def sum_list(lst1, lst2):\n    return [a + b for a, b in zip(lst1, lst2)]",
        "def add_list(a, b): \n    return list(map(lambda x, y: x + y, a, b))",
        "def consecutive_duplicates(lst):\n    result = [lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i]!= lst[i-1]:\n            result.append(lst[i])\n    return result",
        "def lateralsurface_cone(radius, slant_height):\n    import math\n    return math.pi * radius * slant_height",
        "replace_specialchar = lambda s: s.replace(' ', ':').replace(',', ':').replace('.', ':')",
        "def find_first_occurrence(arr, target): \n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right: \n        mid = left + (right - left) // 2\n        if arr[mid] == target: \n            result = mid \n            right = mid - 1\n        elif arr[mid] < target: \n            left = mid + 1\n        else: \n            right = mid - 1\n    return result",
        "def sum_Of_Subarray_Prod(arr, n):  \n    total_sum = 0\n    for i in range(n): \n        prod = 1\n        for j in range(i, n): \n            prod *= arr[j] \n            total_sum += prod \n    return total_sum",
        "def toggle_middle_bits(n): \n    if n == 1: \n        return 1 \n    mask = (1 << (n.bit_length() - 2)) - 1 \n    return n ^ mask",
        "def left_insertion(arr, val):    \n    return len(arr) if val > arr[-1] else next((i for i, v in enumerate(arr) if v >= val), 0)",
        "import re\n\ndef check_str(s):\n    return 'Valid' if re.match(r'^[AEIOUaeiou]', s) else 'Invalid'",
        "def geometric_sum(n):\n    if n < 0:\n        return 0\n    elif n == 0:\n        return 1\n    else:\n        return 1 / (2 ** n) + geometric_sum(n - 1)",
        "def find_Index(n): \n    low, high = 1, 100000 \n    while low <= high: \n        mid = (low + high) // 2\n        triangular_number = (mid * (mid + 1)) // 2\n        num_digits = len(str(triangular_number))\n        if num_digits == n: \n            return mid - 1 \n        elif num_digits < n: \n            low = mid + 1\n        else: \n            high = mid - 1\n    return low - 1",
        "def tuple_to_dict(tup):  \n    dict_result = {}  \n    for i in range(0, len(tup)-1, 2):  \n        dict_result[tup[i]] = tup[i+1]  \n    return dict_result",
        "def all_Characters_Same(s): \n    return len(set(s)) == 1",
        "def area_tetrahedron(side_length):\n    return (side_length ** 2 * (3 ** 0.5)) / 2",
        "def rotate_right(lst, k, n):\n    k = k % n\n    return lst[-k:] + lst[:-k]",
        "def check_none(test_tuple): \n    return None in test_tuple",
        "def divisible_by_digits(start, end):\n    def is_divisible_by_its_digits(n):\n        for digit in str(n):\n            if digit == '0' or n % int(digit)!= 0:\n                return False\n        return True\n    \n    result = []\n    for num in range(start, end + 1):\n        if is_divisible_by_its_digits(num):\n            result.append(num)\n    return result",
        "def sector_area(radius, angle):\n    import math\n    return (math.pi * radius ** 2) * (angle / 360)",
        "def lcs_of_three(str1, str2, str3, m, n, o):\n    dp = [[[0 for i in range(o+1)] for j in range(n+1)] for k in range(m+1)]\n    for i in range(m+1):\n        for j in range(n+1):\n            for k in range(o+1):\n                if i == 0 or j == 0 or k == 0:\n                    dp[i][j][k] = 0\n                elif str1[i-1] == str2[j-1] == str3[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])\n    return dp[m][n][o]",
        "import re\n\ndef capital_words_spaces(text):\n    return re.sub(r'(\\w)([A-Z])', r'\\1 \\2', text)",
        "def sort_numeric_strings(lst):\n    return sorted(lst, key=lambda x: int(x))",
        "def add_tuple(lst, tup): \n    return lst + list(tup)",
        "def check_min_heap(arr, i):  \n    left = 2 * i + 1  \n    right = 2 * i + 2  \n    length = len(arr)  \n    \n    if left < length and arr[i] > arr[left]:  \n        return False  \n    if right < length and arr[i] > arr[right]:  \n        return False  \n    \n    if left < length:  \n        check_min_heap(arr, left)  \n    if right < length:  \n        check_min_heap(arr, right)  \n    \n    return True",
        "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + 2 * b\n        return b",
        "def min_k(lst, k): \n    return sorted(lst, key=lambda x: x[1])[:k]",
        "def extract_index_list(lst1, lst2, lst3):\n    result = []\n    for i in range(min(len(lst1), len(lst2), len(lst3))):\n        if lst1[i] == lst2[i] == lst3[i]:\n            result.append(i)\n    return result",
        "def second_smallest(numbers):\n    smallest = None\n    second_smallest = None\n    for number in numbers:\n        if smallest is None or number < smallest:\n            second_smallest = smallest\n            smallest = number\n        elif second_smallest is None or (number > smallest and (second_smallest is None or number < second_smallest)):\n            second_smallest = number\n    return second_smallest",
        "def text_match_zero_one(text):\n    import re\n    pattern = r'a(b?)'\n    result = re.search(pattern, text)\n    if result:\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
        "def count_reverse_pairs(lst): \n    count = 0\n    for i in range(len(lst)): \n        for j in range(i+1, len(lst)): \n            if lst[i] == lst[j][::-1]: \n                count += 1\n    return str(count)",
        "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict",
        "def is_decimal(s): \n    try: \n        float(s) \n        return True \n    except ValueError: \n        return False \n    except: \n        return False",
        "def unique_Element(arr, n): \n    for i in range(n): \n        if arr[i]!= arr[0]: \n            return 'NO'\n    return 'YES'",
        "def arc_length(r, theta):\n    import math\n    return r * math.radians(theta)",
        "def check_monthnumber_number(month):  \n    if month in [4, 6, 9, 11]:  \n        return True  \n    else:  \n        return False",
        "def find_Min_Diff(arr, n): \n    arr.sort() \n    min_diff = float('inf') \n    for i in range(n-1): \n        if arr[i+1] - arr[i] < min_diff: \n            min_diff = arr[i+1] - arr[i] \n    return min_diff",
        "def number_ctr(s):  \n    count = 0  \n    for char in s:  \n        if char.isdigit():  \n            count += 1  \n    return count",
        "def is_polite(n):  \n    count = 0  \n    num = 1  \n    while True:  \n        polite = 0  \n        for i in range(1, num + 1):  \n            if (num & (1 << i)) == 0:  \n                polite += 1  \n        if polite > 1:  \n            count += 1  \n        if count == n:  \n            return num  \n        num += 1",
        "pair_wise = lambda l: [(l[i], l[i+1]) for i in range(len(l)-1)]",
        "def get_Pairs_Count(arr, sum, n): \n    count = 0\n    for i in range(n): \n        for j in range(i+1, n): \n            if arr[i] + arr[j] == sum: \n                count += 1\n    return count",
        "def check_Odd_Parity(num):\n    count = 0\n    while num:\n        count ^= num & 1\n        num >>= 1\n    return count == 1",
        "def Diff(list1, list2): \n    return list(set(list1) - set(list2))",
        "def odd_Num_Sum(n):  \n    sum = 0  \n    for i in range(1, 2*n, 2):  \n        sum += i**4  \n    return sum",
        "def check_expression(expression):\n    stack = []\n    opening_brackets = {\"(\", \"[\", \"{\"}\n    closing_brackets = {\")\", \"]\", \"}\"}\n    bracket_map = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n    \n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack or stack.pop()!= bracket_map[char]:\n                return False\n    \n    return not stack",
        "def remove_length(s, k): \n    words = s.split() \n    result =''.join([word for word in words if len(word)!= k]) \n    return result",
        "def occurance_substring(string, substring):  \n    start = 0\n    positions = []  \n    while start < len(string):  \n        pos = string.find(substring, start)  \n        if pos!= -1:  \n            positions.append(pos)  \n            start = pos + 1  \n        else:  \n            break  \n    return (substring, positions[0], positions[-1] if positions else -1)",
        "import re\n\ndef check_email(email):\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n    if re.match(pattern, email):\n        return 'Valid Email'\n    else:\n        return 'Invalid Email'",
        "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True",
        "def count_vowels(s):\n    count = 0\n    vowels = 'aeiouAEIOU'\n    for i in range(1, len(s) - 1):\n        if s[i-1] in vowels and s[i+1] in vowels:\n            count += 1\n    return count",
        "def find_Sum(arr, n):  \n    sum = 0\n    frequency = {}\n    for i in range(n): \n        if arr[i] in frequency: \n            frequency[arr[i]] += 1\n        else: \n            frequency[arr[i]] = 1\n    for i in range(n): \n        if frequency[arr[i]] == 1: \n            sum += arr[i] \n    return sum",
        "def pack_consecutive_duplicates(lst):\n    if not lst:\n        return []\n    result = [[lst[0]]]\n    for i in range(1, len(lst)):\n        if lst[i] == result[-1][0]:\n            result[-1].append(lst[i])\n        else:\n            result.append([lst[i]])\n    return result",
        "def unique_sublists(lst):\n    unique_count = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in unique_count:\n            unique_count[tuple_sublist] += 1\n        else:\n            unique_count[tuple_sublist] = 1\n    return unique_count",
        "def find_combinations(lst):  \n    result = []  \n    for i in range(len(lst)):  \n        for j in range(i+1, len(lst)):  \n            result.append((lst[i][0] + lst[j][0], lst[i][1] + lst[j][1]))  \n            result.append((lst[i][0] + lst[j][1], lst[i][1] + lst[j][0]))  \n    return result",
        "def count_Divisors(n):  \n    count = 0\n    for i in range(1, int(n**0.5) + 1):  \n        if n % i == 0:  \n            if n // i == i:  \n                count += 1\n            else:  \n                count += 2  \n    return \"Even\" if count % 2 == 0 else \"Odd\"",
        "def Odd_Length_Sum(arr):\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        sum_subarray = 0\n        for j in range(i, n):\n            sum_subarray += arr[j]\n            if (j - i + 1) % 2!= 0:\n                total_sum += sum_subarray\n    return total_sum",
        "def rgb_to_hsv(r, g, b):\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    maxc = max(r, g, b)\n    minc = min(r, g, b)\n    v = maxc\n    if minc == maxc:\n        return 0.0, 0.0, v * 100.0\n    s = (maxc - minc) / maxc\n    rc = (maxc - r) / (maxc - minc)\n    gc = (maxc - g) / (maxc - minc)\n    bc = (maxc - b) / (maxc - minc)\n    if r == maxc:\n        h = bc - gc\n    elif g == maxc:\n        h = 2.0 + rc - bc\n    else:\n        h = 4.0 + gc - rc\n    h = (h / 6.0) % 1.0\n    if h < 0:\n        h += 1.0\n    return h * 60.0, s * 100.0, v * 100.0",
        "def mul_even_odd(lst):\n    even = None\n    odd = None\n    \n    for num in lst:\n        if num % 2 == 0:\n            if even is None:\n                even = num\n            else:\n                break\n        else:\n            if odd is None:\n                odd = num\n            else:\n                break\n    \n    if even is None or odd is None:\n        return 0\n    \n    return even * odd",
        "tuple_str_int = lambda s: tuple(map(int, s[1:-1].split(', ')))",
        "def right_insertion(arr, val):    \n    return len(arr) if val > arr[-1] else next((i for i, v in enumerate(arr) if v >= val), len(arr))",
        "def text_match_three(text):\n    import re\n    pattern = 'ab{3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
        "def new_tuple(lst, str):  \n    return tuple(lst + [str])",
        "def perimeter_polygon(sides, length):  \n    return sides * length",
        "def even_position(lst):  \n    for i in range(0, len(lst), 2):  \n        if lst[i] % 2!= 0:  \n            return False  \n    return True",
        "def remove_nested(tup): \n    return tuple(item for item in tup if not isinstance(item, tuple))",
        "def count_list(lst): \n    return len(lst)",
        "def last(arr, target, n): \n    low = 0\n    high = n - 1\n    res = -1\n    while (low <= high): \n        mid = int((low + high) / 2) \n        if (arr[mid] > target): \n            high = mid - 1\n        elif (arr[mid] < target): \n            low = mid + 1\n        else: \n            res = mid \n            low = mid + 1\n    return res",
        "def text_starta_endb(s): \n    import re\n    pattern = r'^a.*b$'\n    if re.search(pattern, s): \n        return 'Found a match!'\n    else: \n        return 'Not a match.'",
        "def cheap_items(data, n):\n    import heapq\n    cheapest = heapq.nsmallest(n, data, key=lambda x: x['price'])\n    return cheapest",
        "def return_sum(d):  \n    return sum(d.values())",
        "def sum_in_Range(l, r):\n    return sum(x for x in range(l, r+1) if x % 2!= 0)",
        "def _sum(arr):\n    return sum(arr)",
        "def left_Rotate(num, d):  \n    d = d % 32  \n    num = num << d  \n    num = num | (num >> 32 - d)  \n    return num & 0xFFFFFFFF",
        "def remove_all_spaces(s): \n    return s.replace(\" \", \"\")",
        "def test_three_equal(a, b, c): \n    if a == b == c: \n        return 3 \n    elif a == b or b == c or a == c: \n        return 2 \n    else: \n        return 0",
        "def count_Rotation(arr, n): \n    min_index = 0\n    for i in range(1, n): \n        if arr[i] < arr[min_index]: \n            min_index = i \n    return min_index",
        "def is_Perfect_Square(n): \n    root = int(n**0.5) \n    return root*root == n",
        "def is_Product_Even(numbers, n):  \n    product = 1  \n    for i in range(n):  \n        product *= numbers[i]  \n    return product % 2 == 0",
        "def max_sum_list(lst):\n    return max(lst, key=sum)",
        "def max_run_uppercase(s):\n    max_run = 0\n    current_run = 0\n    for char in s:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n    return max_run",
        "def first_odd(numbers):\n    for num in numbers:\n        if num % 2!= 0:\n            return num\n    return None",
        "def check_K(tup, k):  \n    return k in tup",
        "def check_smaller(t1, t2):  \n    return all(x > y for x, y in zip(t1, t2))",
        "def count_variable(p, q, r, s):\n    result = []\n    for elem in [p, q, r, s]:\n        if elem > 0:\n            result.extend([chr(abs(elem))] * abs(elem))\n    return result",
        "def check_identical(list1, list2): \n    return list1 == list2",
        "def road_rd(st): \n    return st.replace(\"Road\", \"Rd.\")",
        "def string_length(s):\n    return len(s)",
        "def rombus_area(diagonal1, diagonal2):\n    return 0.5 * diagonal1 * diagonal2",
        "def sort_by_dnf(arr, n):  \n    low = 0\n    mid = 0\n    high = n - 1\n    \n    while mid <= high: \n        if arr[mid] == 0: \n            arr[low], arr[mid] = arr[mid], arr[low] \n            low += 1\n            mid += 1\n        elif arr[mid] == 1: \n            mid += 1\n        else: \n            arr[mid], arr[high] = arr[high], arr[mid] \n            high -= 1",
        "def clear_tuple(t):  \n    return ()",
        "div_of_nums = lambda nums, m, n: [num for num in nums if num % m == 0 or num % n == 0]",
        "def lower_ctr(s):  \n    count = 0  \n    for char in s:  \n        if char.islower():  \n            count += 1  \n    return count",
        "def count_duplic(lst):\n    if not lst:\n        return [], []\n    result = []\n    counts = []\n    current = lst[0]\n    count = 1\n    for i in range(1, len(lst)):\n        if lst[i] == current:\n            count += 1\n        else:\n            result.append(current)\n            counts.append(count)\n            current = lst[i]\n            count = 1\n    result.append(current)\n    counts.append(count)\n    return result, counts",
        "def check_monthnum_number(month):\n    return month!= 2",
        "def merge_dictionaries(dict1, dict2): \n    return {**dict1, **dict2}",
        "def pass_validity(password):\n    if len(password) < 8:\n        return False\n    has_digit = any(char.isdigit() for char in password)\n    has_upper = any(char.isupper() for char in password)\n    has_lower = any(char.islower() for char in password)\n    if has_digit and has_upper and has_lower:\n        return True\n    return False",
        "def check_substring(string, substring): \n    import re\n    pattern = re.compile(r'^' + re.escape(substring)) \n    match = pattern.search(string) \n    if match: \n        return'string starts with the given substring' \n    else: \n        return'string doesnt start with the given substring'",
        "def remove_even(lst): \n    return [x for x in lst if x % 2!= 0]",
        "def access_elements(lst, indices): \n    return [lst[i] for i in indices]",
        "def check_Type_Of_Triangle(a, b, c): \n    if a + b <= c or a + c <= b or b + c <= a: \n        return \"Not a Triangle\" \n    elif a == b == c: \n        return \"Equilateral Triangle\" \n    elif a == b or b == c or c == a: \n        return \"Isosceles Triangle\" \n    elif a*a + b*b < c*c or b*b + c*c < a*a or c*c + a*a < b*b: \n        return \"Obtuse-angled Triangle\" \n    else: \n        return \"Acute-angled Triangle\"",
        "def sum_column(data, col): \n    return sum(row[col] for row in data)",
        "def count_alpha_dig_spl(s):\n    alpha = 0\n    dig = 0\n    spl = 0\n    for char in s:\n        if char.isalpha():\n            alpha += 1\n        elif char.isdigit():\n            dig += 1\n        else:\n            spl += 1\n    return (alpha, dig, spl)",
        "def second_frequent(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    sorted_freq = sorted(frequency.items(), key=lambda x: x[1], reverse=True)\n    \n    if len(sorted_freq) < 2:\n        return None\n    else:\n        return sorted_freq[1][0]",
        "def round_up(number, digits): \n    multiplier = 10 ** digits \n    return math.ceil(number * multiplier) / multiplier",
        "def count_Pairs(arr, n):  \n    count = 0\n    for i in range(n): \n        for j in range(i+1, n): \n            if arr[i] == arr[j]: \n                count += 1\n    return count",
        "import re\n\ndef extract_max(s):\n    numbers = re.findall('\\d+', s)\n    return max(map(int, numbers))",
        "get_key = lambda d: list(d.keys())",
        "def generate_matrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    num = 1\n    top, bottom, left, right = 0, n - 1, 0, n - 1\n    \n    while num <= n * n:\n        for i in range(left, right + 1):\n            matrix[top][i] = num\n            num += 1\n        top += 1\n        \n        for i in range(top, bottom + 1):\n            matrix[i][right] = num\n            num += 1\n        right -= 1\n        \n        for i in range(right, left - 1, -1):\n            matrix[bottom][i] = num\n            num += 1\n        bottom -= 1\n        \n        for i in range(bottom, top - 1, -1):\n            matrix[i][left] = num\n            num += 1\n        left += 1\n    \n    return matrix",
        "def slope(x1, y1, x2, y2): \n    return (y2 - y1) / (x2 - x1)",
        "def max_sub_array_sum(arr, n): \n    max_so_far = arr[0] \n    curr_max = arr[0] \n  \n    for i in range(1,n): \n        curr_max = max(arr[i], curr_max + arr[i]) \n        max_so_far = max(max_so_far, curr_max) \n  \n    return max_so_far",
        "def cube_Sum(n):  \n    sum = 0  \n    for i in range(1, 2*n, 2):  \n        sum += i**3  \n    return sum",
        "def min_Swaps(s1, s2): \n    count_0_s1 = s1.count('0') \n    count_1_s2 = s2.count('1') \n    return abs(count_0_s1 - count_1_s2)",
        "def sort_tuple(lst): \n    return sorted(lst, key=lambda x: x[0])",
        "def Check_Solution(a, b, c): \n    if b == 0: \n        return \"No\" \n    else: \n        return \"Yes\"",
        "def get_inv_count(arr, n): \n    inv_count = 0\n    for i in range(n): \n        for j in range(i + 1, n): \n            if arr[i] > arr[j]: \n                inv_count += 1\n    return inv_count",
        "def get_odd_occurence(arr, n): \n    result = 0\n    for i in range(n): \n        result ^= arr[i] \n    return result",
        "def nth_super_ugly_number(n, primes):\n    import heapq\n    if n == 1:\n        return 1\n    heap = [1]\n    seen = {1}\n    for _ in range(n - 1):\n        curr_ugly = heapq.heappop(heap)\n        for prime in primes:\n            new_ugly = curr_ugly * prime\n            if new_ugly not in seen:\n                seen.add(new_ugly)\n                heapq.heappush(heap, new_ugly)\n    return heapq.heappop(heap)",
        "def get_Number(n, k): \n    odd_count = (n + 1) // 2 \n    if k <= odd_count: \n        return 2 * k - 1 \n    else: \n        return 2 * (k - odd_count)",
        "def find_Digits(n): \n    if n < 0: \n        return 0 \n    elif n <= 1: \n        return 1\n    else: \n        digits = 0 \n        factorial = 1 \n        for i in range(2, n + 1): \n            factorial *= i \n            while factorial % 10 == 0: \n                digits += 1\n                factorial //= 10\n            factorial_str = str(factorial) \n            digits += len(factorial_str) \n        return digits",
        "def find_platform(arr, dep, n): \n    arr.sort() \n    dep.sort() \n    platform = 1\n    res = 1\n    i = 1\n    j = 0\n    while i < n and j < n: \n        if arr[i] <= dep[j]: \n            platform += 1\n            i += 1\n            res = max(res, platform) \n        else: \n            platform -= 1\n            j += 1\n    return res",
        "def lcopy(lst): \n    return list(lst)",
        "def area_trapezium(base1, base2, height):\n    return 0.5 * (base1 + base2) * height",
        "def Sum(n): \n    sum = 0\n    i = 2\n    while i * i <= n: \n        if n % i: \n            i += 1\n        else: \n            n //= i \n            if n % i: \n                sum += i \n    if n > 1: \n        sum += n \n    return sum",
        "def is_triangleexists(a, b, c): \n    return a + b + c == 180 and a > 0 and b > 0 and c > 0",
        "def Sum_of_Inverse_Divisors(n, m):  \n    total = 0  \n    for i in range(1, m + 1):  \n        if n % i == 0:  \n            total += 1 / i  \n    return total",
        "def remove_negs(lst):  \n    return [num for num in lst if num >= 0]",
        "def sum_of_odd_Factors(n): \n    result = 1\n    for i in range(2, int(n**0.5) + 1): \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while n % i == 0: \n            count += 1\n            n //= i \n            curr_term *= i \n            if count == 1: \n                curr_sum *= (curr_term + 1) \n            else: \n                curr_sum += curr_term + 1\n        result *= curr_sum  \n    if n >= 2: \n        result *= 2  \n    return result if n == 1 else result * (1 + n)",
        "def raw_heap(arr):  \n    import heapq  \n    heapq.heapify(arr)  \n    return list(arr)",
        "def check_Even_Parity(num): \n    count = 0\n    while num: \n        count += num & 1\n        num >>= 1\n    return count % 2 == 0",
        "def find_Min_Swaps(arr, n):    \n    swaps = 0\n    for i in range(n-1):\n        if arr[i] == 0:\n            j = i\n            while j < n and arr[j] == 0:\n                j += 1\n            if j < n:\n                while j > i:\n                    arr[j], arr[j-1] = arr[j-1], arr[j]\n                    swaps += 1\n                    j -= 1\n    return swaps",
        "def listify_list(colors):\n    return list(map(list, colors))",
        "def count_list(lst):\n    count = sum(1 for x in lst if isinstance(x, list))\n    return count ** 2",
        "def sub_lists(lst): \n    subs = [[]] \n    for i in range(len(lst)): \n        for j in range(i+1, len(lst)+1): \n            subs.append(lst[i:j]) \n    return subs",
        "import re\n\ndef check_alphanumeric(s):\n    if re.match(r'.*[A-Za-z0-9]$', s):\n        return 'Keep'\n    else:\n        return 'Discard'",
        "anagram_lambda = lambda lst, s: [word for word in lst if sorted(word) == sorted(s)]",
        "def n_common_words(text, n):\n    words = text.split()\n    word_count = {}\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    sorted_word_count = sorted(word_count.items(), key=lambda x: x[1], reverse=True)\n    return sorted_word_count[:n]",
        "def find_longest_conseq_subseq(arr, n):  \n    longest = 0\n    for i in range(n): \n        current = 1\n        j = i + 1\n        while j < n and (arr[j] == arr[j - 1] + 1 or arr[j] == arr[j - 1]): \n            current += 1\n            j += 1\n        longest = max(longest, current) \n    return longest",
        "palindrome_lambda = lambda lst: list(filter(lambda s: s == s[::-1], lst))",
        "def ntimes_list(lst, n):\n    return list(map(lambda x: x * n, lst))",
        "def check_monthnumb(month):\n    if month == \"February\":\n        return False\n    else:\n        return True",
        "def min_Num(arr, n): \n    sum_arr = sum(arr) \n    if sum_arr % 2 == 0: \n        return 1\n    else: \n        return 0",
        "def length_Of_Last_Word(s): \n    words = s.split() \n    return len(words[-1])",
        "def remove_list_range(lst, lower, upper):  \n    return [sublist for sublist in lst if all(lower <= x <= upper for x in sublist)]",
        "sum_positivenum = lambda nums: sum(num for num in nums if num > 0)",
        "def are_Rotations(s1, s2):  \n    if len(s1)!= len(s2): \n        return False\n    temp = s1 + s1 \n    return temp.find(s2)!= -1",
        "def check_subset(main_list, subset_list): \n    for sub_list in subset_list: \n        if not any(set(sub_list).issubset(set(main_sub_list)) for main_sub_list in main_list): \n            return False \n    return True",
        "def fibonacci(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)",
        "def check_Concat(s, t): \n    if s.count(t) * len(t) == len(s): \n        return True \n    else: \n        return False",
        "def min_difference(pairs):\n    min_diff = float('inf')\n    for i in range(len(pairs)):\n        for j in range(i+1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            min_diff = min(min_diff, diff)\n    return min_diff",
        "def lcm(a, b):  \n    def gcd(x, y):  \n        while(y):  \n            x, y = y, x % y  \n        return x  \n    return (a * b) // gcd(a, b)",
        "def sort_String(s): \n    return ''.join(sorted(s))",
        "def check_tuples(tup, k): \n    return len(tup) == len(set(k))",
        "import re\n\ndef text_match(text):\n    patterns = 'a.*b$'\n    if re.search(patterns, text):\n        return 'Matched'\n    else:\n        return 'Not matched!'",
        "def Check_Solution(a, b, c): \n    discriminant = b**2 - 4*a*c\n    if discriminant > 0: \n        return \"2 solutions\"\n    elif discriminant == 0: \n        return \"1 solution\"\n    else: \n        return \"No real solutions\"",
        "def sum_even_odd(lst):\n    first_even = next((x for x in lst if x % 2 == 0), None)\n    first_odd = next((x for x in lst if x % 2!= 0), None)\n    return first_even + first_odd if first_even is not None and first_odd is not None else None",
        "def parallelogram_perimeter(base, side):  \n    return 2 * (base + side)",
        "div_of_nums = lambda nums, m, n: [num for num in nums if num % m == 0 and num % n == 0]",
        "def all_Bits_Set_In_The_Given_Range(num, start, end):\n    mask = ((1 << (end - start + 1)) - 1) << start\n    return (num & mask) == mask",
        "def is_Isomorphic(s, t): \n    if len(s)!= len(t): \n        return False\n    \n    s_to_t = {} \n    t_to_s = {} \n    \n    for i in range(len(s)): \n        if s[i] in s_to_t: \n            if s_to_t[s[i]]!= t[i]: \n                return False\n        else: \n            s_to_t[s[i]] = t[i] \n            \n        if t[i] in t_to_s: \n            if t_to_s[t[i]]!= s[i]: \n                return False\n        else: \n            t_to_s[t[i]] = s[i] \n            \n    return True",
        "def sum_num(nums):\n    return sum(nums) / len(nums)",
        "def is_odd(n):  \n    return n & 1 == 1",
        "def substract_elements(t1, t2): \n    return tuple((a - b for a, b in zip(i, j)) for i, j in zip(t1, t2))",
        "def reverse_list_lists(lst):  \n    return [sublist[::-1] for sublist in lst]",
        "def find_Extra(arr1, arr2, n): \n    for i in range(n): \n        if arr1[i]!= arr2[i]: \n            return i \n    return n",
        "def same_Length(num1, num2): \n    len1 = len(str(num1)) \n    len2 = len(str(num2)) \n    return len1 == len2 \n\nsame_Length(12, 1) == False",
        "def remove_spaces(s): \n    return s.replace(\"  \", \" \").replace(\"  \", \" \").replace(\"  \", \" \").replace(\"  \", \" \").replace(\"  \", \" \")",
        "def Extract(lst): \n    return [item[-1] for item in lst]",
        "def float_to_tuple(input_string):\n    return tuple(map(float, input_string.split(', ')))",
        "def max_sum_subseq(arr):\n    if not arr:\n        return 0\n    n = len(arr)\n    if n == 1:\n        return arr[0]\n    dp = [0] * n\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + arr[i])\n    return dp[-1]",
        "def sort_list_last(lst): \n    return sorted(lst, key=lambda x: x[-1])",
        "def is_Word_Present(sentence, word): \n    return word in sentence",
        "def extract_elements(lst, n):\n    result = []\n    for i in range(len(lst) - n + 1):\n        result.append(lst[i:i+n])\n    return result[0] if result else []",
        "def check(arr, n): \n    i = 1\n    while i < n-1: \n        if arr[i] < arr[i-1] and arr[i] < arr[i+1]: \n            i += 1\n        elif arr[i] > arr[i-1] and arr[i] > arr[i+1]: \n            i += 1\n        else: \n            return False\n    return True",
        "def match_num(s): \n    return s.startswith('5')",
        "def smallest_multiple(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) // math.gcd(result, i)\n    return result",
        "def add_dict(d1, d2):\n    from collections import Counter\n    combined = Counter(d1) + Counter(d2)\n    return dict(combined)",
        "def count_Unset_Bits(n):  \n    count = 0  \n    for i in range(1, n + 1):  \n        count += bin(i).count('0') - 1  \n    return count",
        "def even_num(n):  \n    return n % 2 == 0",
        "def sum_of_square(n):  \n    if n == 0: \n        return 0\n    elif n == 1: \n        return 1\n    else: \n        return 2 * sum_of_square(n - 1) + n * n",
        "import re\n\ndef extract_date(url):\n    pattern = r'/(\\d{4})/(\\d{2})/(\\d{2})/'\n    match = re.search(pattern, url)\n    if match:\n        return [match.groups()]\n    else:\n        return []",
        "def lucky_num(n):\n    nums = list(range(1, n*10, 2))\n    while len(nums) > 1:\n        step = nums[1]\n        nums = [nums[i] for i in range(len(nums)) if (i+1) % step!= 0]\n    return nums[:n]",
        "def find_fixed_point(arr, n): \n    for i in range(n): \n        if arr[i] == i: \n            return i \n    return -1",
        "def previous_palindrome(n):\n    n -= 1\n    while not str(n) == str(n)[::-1]:\n        n -= 1\n    return n",
        "def check_date(day, month, year): \n    if year < 1583: \n        return False \n    if month < 1 or month > 12: \n        return False \n    if day < 1 or day > 31: \n        return False \n    if month in [4, 6, 9, 11] and day > 30: \n        return False \n    if month == 2: \n        if year % 4 == 0: \n            if year % 100 == 0: \n                if year % 400 == 0: \n                    if day > 29: \n                        return False \n                    else: \n                        return True \n                else: \n                    if day > 28: \n                        return False \n                    else: \n                        return True \n            else: \n                if day > 29: \n                    return False \n                else: \n                    return True \n        else: \n            if day > 28: \n                return False \n            else: \n                return True \n    else: \n        return True",
        "def maximum_product(nums):\n    import heapq\n    max_heap = [-num for num in nums]\n    heapq.heapify(max_heap)\n    num1 = -heapq.heappop(max_heap)\n    num2 = -heapq.heappop(max_heap)\n    num3 = -heapq.heappop(max_heap)\n    return num1 * num2 * num3",
        "def lobb_num(n, m):\n    from math import comb\n    return 2 * (2 * n + 1) * comb(2 * n + m, n + 1) // (n + m + 1)",
        "def end_num(s): \n    return s.isdigit() or (s[-1].isdigit() and not s[-2].isdigit())",
        "def is_Two_Alter(s): \n    if len(s) < 2: \n        return False \n    \n    first_char = s[0] \n    second_char = s[1] \n    \n    for i in range(2, len(s)): \n        if s[i] == first_char: \n            return False \n        first_char, second_char = second_char, s[i] \n    \n    return True",
        "def rearrange_numbs(arr): \n    return sorted(arr, key=lambda x: (x < 0, x))",
        "def find_triplet_array(arr, n, target): \n    arr.sort() \n    for i in range(0, n-2): \n        l = i + 1\n        r = n - 1\n        while l < r: \n            if arr[i] + arr[l] + arr[r] == target: \n                return (arr[i], arr[l], arr[r]) \n            elif arr[i] + arr[l] + arr[r] < target: \n                l += 1\n            else: \n                r -= 1\n    return ()",
        "def text_uppercase_lowercase(s):  \n    import re  \n    pattern = re.compile(r'[A-Z][a-z]+')  \n    result = pattern.search(s)  \n    if result:  \n        return 'Found a match!'  \n    else:  \n        return 'No match found.'",
        "def coin_change(coins, amount, n): \n    if amount == 0: \n        return 1\n    if amount < 0 or n == 0: \n        return 0\n    return coin_change(coins, amount, n-1) + coin_change(coins, amount-coins[n-1], n)",
        "def multiply_list(lst):\n    result = 1\n    for num in lst:\n        result *= num\n    return result",
        "def remove_tuple(lst):  \n    return [t for t in lst if not all(v is None for v in t)]",
        "def chunk_tuples(tup, n):  \n    return [tup[i:i+n] for i in range(0, len(tup), n)]",
        "def max_product(arr):\n    if len(arr) < 2:\n        return None\n    max1 = max(arr[0], arr[1])\n    max2 = min(arr[0], arr[1])\n    min1 = max(arr[0], arr[1])\n    min2 = min(arr[0], arr[1])\n    for i in range(2, len(arr)):\n        if arr[i] > max1:\n            max2 = max1\n            max1 = arr[i]\n        elif arr[i] > max2:\n            max2 = arr[i]\n        if arr[i] < min1:\n            min2 = min1\n            min1 = arr[i]\n        elif arr[i] < min2:\n            min2 = arr[i]\n    return (min1, max1) if max1 * max2 < min1 * min2 else (max1, max2)",
        "def super_seq(str1, str2, m, n): \n    dp = [[0] * (n + 1) for _ in range(m + 1)] \n  \n    for i in range(m + 1): \n        for j in range(n + 1): \n            if i == 0: \n                dp[i][j] = j \n            elif j == 0: \n                dp[i][j] = i \n            elif str1[i - 1] == str2[j - 1]: \n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else: \n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) \n  \n    return dp[m][n]",
        "def max_of_two(a, b):\n    if a > b:\n        return a\n    else:\n        return b",
        "def mutiple_tuple(tup): \n    product = 1\n    for num in tup: \n        product *= num \n    return product",
        "def rencontres_number(n, k):\n    if n == k:\n        return 0\n    if n == 0 or k == 0:\n        return 1\n    return (k * rencontres_number(n - 1, k)) + (k - 1) * rencontres_number(n - 1, k - 1)",
        "def max_height(root):  \n    if root is None:  \n        return -1  \n    else:  \n        left_height = max_height(root.left)  \n        right_height = max_height(root.right)  \n        return 1 + max(left_height, right_height)",
        "def change_date_format(date):  \n    year, month, day = date.split('-')  \n    return f'{day}-{month}-{year}'",
        "def count_tuplex(tuplex, item): \n    return tuplex.count(item)",
        "import re\n\ndef text_match(text):\n    patterns = 'ab*'\n    \n    if re.search(patterns, text):\n        return 'Matched'\n    else:\n        return 'Not matched!'",
        "def sum_series(n):\n    total = 0\n    for i in range(1, n+1):\n        total += i**3\n    return total",
        "def remove_duplic_list(lst):\n    seen = set()\n    result = []\n    for word in lst:\n        if word not in seen:\n            seen.add(word)\n            result.append(word)\n    return result",
        "import re\n\ndef camel_to_snake(s):\n    return re.sub(r'([a-z0-9])([A-Z])', r'\\1_\\2', s).lower()",
        "def dealnnoy_num(m, n):\n    if m == 0 or n == 0:\n        return 1\n    return dealnnoy_num(m - 1, n) + dealnnoy_num(m, n - 1) + dealnnoy_num(m - 1, n - 1)",
        "def series_sum(n):\n    return sum(i**2 for i in range(1, n+1))",
        "def re_arrange_tuples(tuples, order):\n    indexed_tuples = [(index, tuple) for index, tuple in enumerate(tuples)]\n    indexed_tuples.sort(key=lambda x: order.index(x[0]))\n    return [tuple for _, tuple in indexed_tuples]",
        "def max_char(s):    \n    char_count = {}    \n    for char in s:        \n        if char in char_count:            \n            char_count[char] += 1        \n        else:            \n            char_count[char] = 1    \n    max_char = max(char_count, key=char_count.get)    \n    return (max_char,)",
        "def find_closet(arr1, arr2, arr3, n, m, k): \n    i, j, l = 0, 0, 0\n    result = []\n    min_diff = float('inf')\n    \n    while i < n and j < m and l < k: \n        min_val = min(arr1[i], arr2[j], arr3[l]) \n        max_val = max(arr1[i], arr2[j], arr3[l]) \n        if max_val - min_val < min_diff: \n            min_diff = max_val - min_val \n            result = [arr1[i], arr2[j], arr3[l]] \n        if arr1[i] == min_val: \n            i += 1\n        elif arr2[j] == min_val: \n            j += 1\n        else: \n            l += 1\n    \n    return tuple(result)",
        "sorted_models = lambda lst: sorted(lst, key=lambda x: (x['make'], x['model']))",
        "def heap_sort(arr):  \n    n = len(arr)  \n  \n    # Build a maxheap. \n    for i in range(n // 2 - 1, -1, -1): \n        heapify(arr, n, i) \n  \n    # One by one extract elements \n    for i in range(n-1, 0, -1): \n        arr[i], arr[0] = arr[0], arr[i] # swap \n        heapify(arr, i, 0) \n  \ndef heapify(arr, n, i): \n    largest = i # Initialize largest as root \n    l = 2 * i + 1     # left = 2*i + 1 \n    r = 2 * i + 2     # right = 2*i + 2 \n  \n    # See if left child of root exists and is \n    # greater than root \n    if l < n and arr[i] < arr[l]: \n        largest = l \n  \n    # See if right child of root exists and is \n    # greater than root \n    if r < n and arr[largest] < arr[r]: \n        largest = r \n  \n    # Change root, if needed \n    if largest!= i: \n        arr[i],arr[largest] = arr[largest],arr[i] # swap \n  \n        # Heapify the root. \n        heapify(arr, n, largest)",
        "def count_elim(lst):\n    count = 0\n    for element in lst:\n        if isinstance(element, tuple):\n            break\n        count += 1\n    return count",
        "def check_element(lst1, lst2): \n    for element in lst2: \n        if element in lst1: \n            return True \n    return False",
        "import heapq\n\ndef combine_lists(list1, list2):\n    return list(heapq.merge(list1, list2))",
        "def num_position(s):\n    words = s.split()\n    for i, word in enumerate(words):\n        for char in word:\n            if char.isdigit():\n                print(f\"Number: {char}, Position: {i * len(word) + words.index(word) + 1}\")",
        "def tuple_to_set(tup):  \n    return set(tup)",
        "def most_common_elem(text, n): \n    from collections import Counter \n    cnt = Counter(text) \n    common = cnt.most_common(n) \n    return common",
        "def len_log(words):\n    return min(len(word) for word in words)",
        "def get_item(tup, index):  \n    return tup[index]",
        "def sort_list(lst): \n    return sorted(lst, key=lambda x: sum(len(str(i)) for i in x))",
        "def chinese_zodiac(year):\n    zodiacs = ['Monkey', 'Rooster', 'Dog', 'Pig', 'Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', 'Snake', 'Horse', 'Sheep']\n    return zodiacs[(year - 1900) % 12]",
        "def max_similar_indices(list1, list2):\n    result = []\n    for t1, t2 in zip(list1, list2):\n        max_tuple = tuple(max(a, b) for a, b in zip(t1, t2))\n        result.append(max_tuple)\n    return result",
        "def nCr_mod_p(n, r, p): \n    if r == 0: \n        return 1\n    fact = [0] * (n + 1) \n    fact[0] = 1\n    for i in range(1, n + 1): \n        fact[i] = fact[i - 1] * i % p \n    return (fact[n] * pow(fact[r], p - 2, p) % p * pow(fact[n - r], p - 2, p) % p) % p",
        "def subset(arr, n):  \n    if n == 0: \n        return 0\n    subset_set = set() \n    min_subsets = 0\n    for i in range(n): \n        current_num = arr[i] \n        j = i - 1\n        while j >= 0 and arr[j] not in subset_set: \n            subset_set.add(arr[j]) \n            j -= 1\n        if j >= 0: \n            subset_set.clear() \n            min_subsets += 1\n    if subset_set: \n        min_subsets += 1\n    return min_subsets",
        "def profit_amount(selling_price, cost_price):\n    if selling_price > cost_price:\n        return selling_price - cost_price\n    else:\n        return None",
        "def is_abundant(n):\n    divisors = [i for i in range(1, n) if n % i == 0]\n    return sum(divisors) > n",
        "import re\n\ndef split_list(s):\n    return re.findall('[A-Z][^A-Z]*', s)",
        "def get_First_Set_Bit_Pos(n):  \n    position = 0  \n    while n > 0:  \n        position += 1  \n        if n & 1:  \n            return position  \n        n >>= 1  \n    return 0",
        "def int_to_roman(num): \n    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] \n    syb = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"] \n    roman_num = '' \n    i = 0\n    while num > 0: \n        for _ in range(num // val[i]): \n            roman_num += syb[i] \n            num -= val[i] \n        i += 1\n    return roman_num",
        "def Average(lst): \n    return sum(lst) / len(lst)",
        "def get_noOfways(n):    \n    if n == 1:        \n        return 1    \n    if n == 2:        \n        return 2    \n    return get_noOfways(n-1) + get_noOfways(n-2)",
        "def roman_to_int(s):\n    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n    for char in reversed(s):\n        current_value = roman_values[char]\n        if current_value < prev_value:\n            total -= current_value\n        else:\n            total += current_value\n        prev_value = current_value\n    return total",
        "def sum_Even(l, r): \n    total = 0\n    for i in range(l, r+1): \n        if i % 2 == 0: \n            total += i \n    return total",
        "def discriminant_value(a, b, c):\n    discriminant = b**2 - 4*a*c\n    return (\"Two solutions\", discriminant) if discriminant > 0 else (\"One solution\", discriminant) if discriminant == 0 else (\"No real solutions\", discriminant)",
        "def word_len(word): \n    return len(word) % 2 == 0",
        "def camel_to_snake(s): \n    return '_'.join([word.lower() for word in ''.join([''+ i if i.isupper() else i for i in s]).split()])",
        "def remove_empty(tuples_list):\n    return [t for t in tuples_list if t or not t and t!= ()]",
        "def check(s):  \n    vowels = set(\"aeiouAEIOU\")  \n    return not set(s) - vowels",
        "def floor_Max(a, b, c): \n    return min(a, b, c)",
        "def join_tuples(lst): \n    from collections import defaultdict \n    \n    d = defaultdict(list) \n    \n    for key, value in lst: \n        d[key].append(value) \n    \n    result = [] \n    for key, values in d.items(): \n        result.append((key, *values)) \n    \n    return result",
        "def min_of_two(a, b): \n    if a < b: \n        return a \n    else: \n        return b",
        "def maximum_segments(n, a, b, c): \n    if n == 0: \n        return 0\n    if n < min(a, b, c): \n        return 0\n    segments = 0\n    segments += maximum_segments(n - a, a, b, c) \n    segments += maximum_segments(n - b, a, b, c) \n    segments += maximum_segments(n - c, a, b, c) \n    return segments + 1 if n >= max(a, b, c) else segments",
        "concatenate_nested = lambda x, y: x + y",
        "def left_rotate(s, n): \n    return s[n:] + s[:n]",
        "def min_sum_path(triangle):\n    n = len(triangle)\n    for i in range(1, n):\n        for j in range(i+1):\n            if j == 0:\n                triangle[i][j] += triangle[i-1][j]\n            elif j == i:\n                triangle[i][j] += triangle[i-1][j-1]\n            else:\n                triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j])\n    return min(triangle[n-1])",
        "def find_Min_Sum(n): \n    if n == 1: \n        return 1\n    min_sum = n \n    i = 2\n    while i * i <= n: \n        while n % i == 0: \n            min_sum += i \n            n //= i \n        i += 1\n    if n > 1: \n        min_sum += n \n    return min_sum",
        "def count_element_freq(test_tup):  \n    freq_dict = {}  \n    for sub in test_tup:  \n        if isinstance(sub, tuple):  \n            for el in sub:  \n                if el in freq_dict:  \n                    freq_dict[el] += 1  \n                else:  \n                    freq_dict[el] = 1  \n        else:  \n            if sub in freq_dict:  \n                freq_dict[sub] += 1  \n            else:  \n                freq_dict[sub] = 1  \n    return freq_dict",
        "def add_str(tup, strToAdd):\n    return list(x + strToAdd for x in tup)",
        "def sum_elements(tup): \n    return sum(tup)",
        "def modular_sum(arr, n, m): \n    mod_sum = [0] * m \n    mod_sum[0] = 1\n    prev_mod = [0] * m \n    for i in range(n): \n        for j in range(m-1, -1, -1): \n            prev_mod[j] = mod_sum[j] \n        for j in range(1, m): \n            mod_sum[j] = prev_mod[(j - arr[i] % m + m) % m] \n        mod_sum[arr[i] % m] = mod_sum[arr[i] % m] + 1\n    return mod_sum[m-1] > 1",
        "def radix_sort(arr):\n    RADIX = 10\n    placement = 1\n    max_digit = max(arr)\n    \n    while placement < max_digit:\n      buckets = [list() for _ in range(RADIX)]\n      for i in arr:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range(RADIX):\n        buck = buckets[b]\n        for i in buck:\n          arr[a] = i\n          a += 1\n      placement *= RADIX\n    return arr",
        "def largest_pos(lst):\n    return max(lst, key=abs) if lst else None",
        "def sqrt_root(n): \n    return n ** 0.5",
        "def volume_tetrahedron(side_length): \n    return (side_length ** 3) / (6 * (2 ** 0.5))",
        "def get_lcm(arr):\n    import math\n    lcm = arr[0]\n    for i in arr[1:]:\n        lcm = lcm * i // math.gcd(lcm, i)\n    return lcm",
        "def check_isosceles(a, b, c): \n    return a!= b and b!= c and a!= c",
        "def lbs(arr):\n    n = len(arr)\n    lis = [1]*n\n    lds = [1]*n\n    for i in range (1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i]< lis[j] + 1 :\n                lis[i] = lis[j]+1\n    for i in range (n-2, -1, -1):\n        for j in range(n-1, i, -1):\n            if arr[i] > arr[j] and lds[i] < lds[j] + 1 :\n                lds[i] = lds[j]+1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i]+lds[i]-1)\n    return maximum",
        "check_string = lambda s: ['String must have 1 upper case character.' if any(c.isupper() for c in s) == False else '', 'String must have 1 number.' if any(c.isdigit() for c in s) == False else '', 'String length should be atleast 8.' if len(s) < 8 else ''].count('') == 0",
        "def max_sum_increasing_subsequence(arr, n):  \n    dp = [0] * n  \n    dp[0] = arr[0]  \n    for i in range(1, n):  \n        dp[i] = arr[i]  \n        for j in range(i):  \n            if arr[i] > arr[j]:  \n                dp[i] = max(dp[i], dp[j] + arr[i])  \n    return max(dp)",
        "def parallel_lines(line1, line2):\n    return line1[0] == line2[0]",
        "def capitalize_first_last_letters(s):\n    return ''.join([word[0].upper() + word[1:-1] + word[-1].upper() if len(word) > 1 else word[0].upper() + word[-1].upper() for word in s.split(' ')])",
        "def get_pairs_count(arr, n, target): \n    count = 0\n    for i in range(n): \n        for j in range(i+1, n): \n            if arr[i] + arr[j] == target: \n                count += 1\n    return count",
        "def min_length(lst): \n    min_len = min(len(sub_lst) for sub_lst in lst) \n    min_lst = [sub_lst for sub_lst in lst if len(sub_lst) == min_len] \n    return min_len, min_lst[0]",
        "def jacobsthal_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b",
        "def negative_count(arr):\n    negative_numbers = [num for num in arr if num < 0]\n    return len(negative_numbers) / len(arr)",
        "def min_coins(coins, count, amount):\n    if amount == 0:\n        return 0\n    if count == 0 and amount!= 0:\n        return float('inf')\n    if coins[count-1] > amount:\n        return min_coins(coins, count-1, amount)\n    return min(min_coins(coins, count-1, amount), 1 + min_coins(coins, count, amount - coins[count-1]))",
        "def check_permutation(s1, s2): \n    if len(s1)!= len(s2): \n        return False \n    else: \n        return sorted(s1) == sorted(s2)",
        "def remove_datatype(test_tup, K): \n    res = [ele for ele in test_tup if not isinstance(ele, K)] \n    return res",
        "def search_literal(literal, string):\n    index = string.find(literal)\n    if index!= -1:\n        return (index, index + len(literal))\n    else:\n        return (-1, -1)",
        "def topbottom_surfacearea(radius):\n    import math\n    return 2 * math.pi * radius * radius",
        "def nth_items(lst, n):\n    return [lst[i] for i in range(0, len(lst), n)]",
        "def first_repeated_word(s):\n    seen = set()\n    for word in s.split():\n        if word in seen:\n            return word\n        seen.add(word)\n    return \"\"",
        "string_list_to_tuple = (lambda s: tuple(s))",
        "basesnum_coresspondingnum = lambda bases, nums: list(map(lambda x, y: x ** y, bases, nums))",
        "def find_Diff(arr,n): \n    freq = [0]*n \n    for i in range(len(arr)): \n        freq[arr[i]] += 1\n    max_freq = max(freq) \n    min_freq = min(freq) \n    return max_freq - min_freq",
        "def check_abundant(n):\n    if n < 1:\n        return False\n    divisors_sum = 1  # 1 is always a divisor\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i!= n // i:\n                divisors_sum += n // i\n    return divisors_sum > n",
        "import re\n\ndef fill_spaces(text):\n    return re.sub(r'[,.]+', ':', text)",
        "def count_digits(num1, num2):\n    sum_num = num1 + num2\n    digit_count = len(str(sum_num))\n    print(digit_count)",
        "def flatten_tuple(test_list):\n    result =''.join([str(val) for sublist in test_list for val in sublist])\n    return result",
        "def toggle_F_and_L_bits(n): \n    first_bit = 1 << (n.bit_length() - 1) \n    last_bit = 1 \n    return n ^ (first_bit | last_bit)",
        "def last_occurence_char(s, char): \n    return s.rfind(char)",
        "def Total_Hamming_Distance(n):\n    total_distance = 0\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            total_distance += bin(i ^ j).count('1')\n    return total_distance",
        "def longest_increasing_subsequence(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range (1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i]< lis[j] + 1 :\n                lis[i] = lis[j]+1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum",
        "def odd_Num_Sum(n):  \n    sum = 0  \n    for i in range(1, 2*n, 2):  \n        sum += i**5  \n    return sum",
        "def find_Max(arr, start, end): \n    if start == end: \n        return arr[start] \n    if end - start == 1: \n        return max(arr[start], arr[end]) \n    mid = (start + end) // 2 \n    if arr[mid] > arr[end]: \n        return find_Max(arr, mid, end) \n    elif arr[mid] < arr[start]: \n        return find_Max(arr, start, mid) \n    else: \n        return arr[start]",
        "def extract_column(matrix, col_index):  \n    return [row[col_index] for row in matrix]",
        "def Seq_Linear(sequence):\n    if len(sequence) < 2:\n        return \"Linear Sequence\"\n    difference = sequence[1] - sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] - sequence[i-1]!= difference:\n            return \"Not Linear Sequence\"\n    return \"Linear Sequence\"",
        "def tuple_to_float(tup): \n    return float(tup[0] + tup[1])",
        "def Split(lst): \n    return [x for x in lst if x % 2!= 0]",
        "def difference(n):\n    sum_of_cubes = sum([i**3 for i in range(1, n+1)])\n    sum_of_numbers = sum(range(1, n+1))\n    return sum_of_cubes - sum_of_numbers",
        "def find_Odd_Pair(arr, n):    \n    odd_count = 0\n    for i in range(n):        \n        for j in range(i+1, n):            \n            if (arr[i] ^ arr[j]) % 2!= 0:                \n                odd_count += 1\n    return odd_count",
        "def toggle_string(s):  \n    return s.swapcase()",
        "def digit_distance_nums(num1, num2): \n    num1_str = str(num1) \n    num2_str = str(num2) \n    max_len = max(len(num1_str), len(num2_str)) \n    distance = 0 \n    for i in range(max_len): \n        digit1 = int(num1_str[i]) if i < len(num1_str) else 0 \n        digit2 = int(num2_str[i]) if i < len(num2_str) else 0 \n        distance += abs(digit1 - digit2) \n    return distance",
        "def max_sub_array_sum(arr, n): \n    max_so_far = arr[0] \n    curr_max = arr[0] \n  \n    for i in range(1,n): \n        curr_max = max(arr[i], curr_max + arr[i]) \n        max_so_far = max(max_so_far, curr_max) \n      \n    return max_so_far",
        "def union_elements(t1, t2):\n    return tuple(set(t1) | set(t2))",
        "def assign_elements(pairs):\n    result = {}\n    for a, b in pairs:\n        if a in result:\n            result[a].append(b)\n        else:\n            result[a] = [b]\n        if b in result:\n            result[b].append(a)\n        else:\n            result[b] = [a]\n    return result",
        "def Find_Max_Length(lst): \n    max_length = 0\n    for sublist in lst: \n        if len(sublist) > max_length: \n            max_length = len(sublist) \n    return max_length",
        "def extract_values(s):\n    return [val.strip('\"') for val in s.split(', ')]",
        "def count_Pairs(arr, n):  \n    count = 0\n    for i in range(n): \n        for j in range(i+1, n): \n            if arr[i]!= arr[j]: \n                count += 1\n    return count",
        "split = lambda s: [c for c in s]",
        "def sum_digits(n):\n    return sum(int(digit) for digit in str(n))",
        "def issort_list(lst):\n    return lst == sorted(lst)",
        "def empty_list(n):  \n    return [{} for _ in range(n)]",
        "def sort_sublists(lst): \n    return [sorted(sublist) for sublist in lst]",
        "def remove_words(lst, chars):    \n    return [''.join([char for char in word if char not in chars]) for word in lst]",
        "def max_sum_pair_diff_lessthan_K(arr, n, k):  \n    arr.sort()  \n    i = 0  \n    j = 1  \n    max_sum = 0  \n    while j < n:  \n        if arr[j] - arr[i] < k:  \n            max_sum += arr[i] + arr[j]  \n            j += 2  \n            i += 1  \n        else:  \n            i += 1  \n            j += 1  \n    return max_sum",
        "def two_unique_nums(arr):\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    \n    result = []\n    for num, count in freq.items():\n        if count == 1:\n            result.append(num)\n    \n    return result",
        "def unique_product(lst):\n    unique_nums = set(lst)\n    product = 1\n    for num in unique_nums:\n        product *= num\n    return product",
        "def surfacearea_cylinder(radius, height):\n    import math\n    return 2 * math.pi * radius * (radius + height)",
        "def count_no(x, y, start, end):\n    count = 0\n    for i in range(start, end + 1):\n        if i % y!= 0:\n            count += 1\n            if count == x:\n                return i\n    return -1",
        "def is_Sub_Array(arr1, arr2, n, m): \n    if m > n: \n        return False\n    for i in range(n - m + 1): \n        flag = True\n        for j in range(m): \n            if arr1[i + j]!= arr2[j]: \n                flag = False\n                break\n        if flag: \n            return True\n    return False",
        "def last_Digit_Factorial(n):  \n    if n == 0 or n == 1: \n        return 1\n    last_digit = 1\n    for i in range(2, n + 1): \n        last_digit = (last_digit * i) % 10\n    return last_digit",
        "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result",
        "def find_dissimilar(t1, t2): \n    return tuple(x for x in t1 if x not in t2) + tuple(x for x in t2 if x not in t1)",
        "def extract_even(t):\n    result = ()\n    for i in t:\n        if isinstance(i, tuple):\n            result += (extract_even(i),)\n        elif i % 2 == 0:\n            result += (i,)\n    return result",
        "def surface_Area(base_edge, slant_height): \n    base_area = base_edge ** 2\n    lateral_area = 2 * base_edge * slant_height\n    surface_area = base_area + lateral_area\n    return surface_area",
        "def my_dict(d): \n    return len(d) == 0",
        "def catalan_number(n):\n    if n == 0:\n        return 1\n    catalan = [0] * (n + 1)\n    catalan[0] = 1\n    catalan[1] = 1\n    for i in range(2, n + 1):\n        catalan[i] = 0\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[n]",
        "import re\n\ndef find_adverbs(sentence):\n    adverbs = re.findall(r'\\b\\w+ly\\b', sentence)\n    result = []\n    for adverb in adverbs:\n        start = sentence.find(adverb)\n        result.append(f'{start}-{start + len(adverb)}: {adverb}')\n    return''.join(result)",
        "def expensive_items(items, n):\n    import heapq\n    expensive = heapq.nlargest(n, items, key=lambda x: x['price'])\n    return expensive",
        "def split_Arr(arr, n, k): \n    part1 = arr[:k] \n    part2 = arr[k:] \n    return part2 + part1",
        "def list_tuple(lst): return tuple(lst)",
        "def big_diff(arr):\n    return max(arr) - min(arr)",
        "def perfect_squares(start, end):\n    squares = []\n    for i in range(int(start**0.5), int(end**0.5) + 1):\n        squares.append(i**2)\n    return squares",
        "def polar_rect(r, theta):\n    x = r * cos(theta)\n    y = r * sin(theta)\n    return ((x, y), (x + y*1j))",
        "def swap_List(newList): \n    newFirst = newList[0]  \n    newLast = newList[-1] \n    if len(newList) > 1: \n        newList[0] = newLast \n        newList[-1] = newFirst \n    return newList",
        "def sum_Of_product(n):  \n    if n == 0: \n        return 0\n    dp = [0] * (n + 1) \n    dp[0] = 1\n    for i in range(1, n + 1): \n        for j in range(i, -1, -1): \n            dp[j] = dp[j] + dp[j - 1] \n    return dp[n] * (n + 1) - 1",
        "def removezero_ip(ip):\n    return '.'.join([str(int(part)) for part in ip.split('.')])",
        "def diff_even_odd(lst):\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0:\n            if first_even is None:\n                first_even = num\n            if first_odd is not None:\n                break\n        else:\n            if first_odd is None:\n                first_odd = num\n            if first_even is not None:\n                break\n    \n    return first_even - first_odd",
        "def min_Swaps(s1, s2):\n    diff_count = 0\n    for i in range(len(s1)):\n        if s1[i]!= s2[i]:\n            diff_count += 1\n    return diff_count // 2 if diff_count % 2 == 0 else diff_count // 2 + 1",
        "def tuple_size(tup):  \n    return sys.getsizeof(tup)",
        "def find_kth(arr1, arr2, m, n, k): \n    if m > n: \n        return find_kth(arr2, arr1, n, m, k) \n    if m == 0: \n        return arr2[k-1] \n    if k == 1: \n        return min(arr1[0], arr2[0]) \n    i = min(m, k // 2) \n    j = k - i \n    if arr1[i-1] < arr2[j-1]: \n        return find_kth(arr1[i:m], arr2, m-i, n, k-i) \n    elif arr1[i-1] > arr2[j-1]: \n        return find_kth(arr1, arr2[j:n], m, n-j, k-j) \n    else: \n        return arr1[i-1]",
        "def armstrong_number(num):\n    order = len(str(num))\n    sum = 0\n    temp = num\n    while temp > 0:\n        digit = temp % 10\n        sum += digit ** order\n        temp //= 10\n    return num == sum",
        "def sum_average(n):\n    sum_n = sum(range(1, n+1))\n    avg_n = sum_n / n\n    return sum_n, avg_n",
        "def is_Even(n): \n    return (n & 1) == 0",
        "def min_cost(cost, m, n):\n    if m < 0 or n < 0:\n        return float('inf')\n    if m == 0 and n == 0:\n        return cost[0][0]\n    return cost[m][n] + min(min_cost(cost, m-1, n), min_cost(cost, m, n-1))",
        "def similar_elements(t1, t2):\n    return tuple(set(t1) & set(t2))",
        "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False",
        "def heap_queue_largest(lst, n): \n    import heapq \n    largest = heapq.nlargest(n, lst) \n    return largest",
        "def count_ways(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 3\n    dp = [0] * (n + 1)\n    dp[0] = 0\n    dp[1] = 1\n    dp[2] = 3\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2] + 2\n    return dp[n]",
        "def differ_At_One_Bit_Pos(a, b): \n    return (a ^ b) & ~(a ^ b + 1) == 0",
        "import re\n\ndef find_char_long(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)",
        "square_nums = lambda nums: list(map(lambda x: x**2, nums))",
        "def find_Rotations(s): \n    if len(s) <= 1: \n        return 0\n    temp = s + s \n    n = len(s) \n    result = n \n    for i in range(n): \n        if temp[i:n+i] == s: \n            result = min(result, i) \n    return result + 1",
        "def small_nnum(lst, n):\n    return sorted(lst)[:n]"
    ]
}