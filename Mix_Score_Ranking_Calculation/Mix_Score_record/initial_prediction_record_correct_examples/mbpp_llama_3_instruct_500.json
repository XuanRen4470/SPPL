{
    "initial_prediction": [
        "def Pair(a, b):\n    return (a, b)\n\ndef max_chain_length(pairs, n):\n    pairs.sort(key=lambda x: x[1])\n    dp = [1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if pairs[j][1] < pairs[i][0]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)",
        "def prime_num(n): \n    if n <= 1: \n        return False \n    elif n <= 3: \n        return True \n    elif n % 2 == 0 or n % 3 == 0: \n        return False \n    i = 5 \n    while i * i <= n: \n        if n % i == 0 or n % (i + 2) == 0: \n            return False \n        i += 6 \n    return True",
        "import math\n\ndef radian_degree(deg):\n    return deg * math.pi / 180",
        "import re\n\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return match.group(), match.start(), match.end()\n    else:\n        return None",
        "def remove_kth_element(lst,k): \n    if k > len(lst): \n        return \"k is greater than the length of the list\" \n    else: \n        return lst[:k-1] + lst[k:]",
        "max_of_nth = lambda lst, n: max(x[n] for x in lst)",
        "def tuple_modulo(t1, t2):\n    return tuple(i % j for i, j in zip(t1, t2))",
        "div_list = lambda l1, l2: list(map(lambda x, y: x/y, l1, l2))",
        "def increment_numerics(lst, k):\n    return [str(int(x) + k) if x.isdigit() else x for x in lst]",
        "def is_upper(s): \n    return s.upper()",
        "def swap_List(lst): \n    if len(lst) > 1: \n        lst[0], lst[-1] = lst[-1], lst[0] \n    return lst",
        "replace_spaces = lambda s: s.replace(' ', '%20')",
        "def Split(lst):\n    return [i for i in lst if i % 2 == 0]",
        "def pair_OR_Sum(arr,n):\n    result = 0\n    for i in range(len(arr)):\n        for j in range(i+1,len(arr)):\n            result += arr[i]^arr[j]\n    return result",
        "import heapq\n\ndef heap_sort(nums):\n    heapq.heapify(nums)\n    result = []\n    while nums:\n        result.append(heapq.heappop(nums))\n    return result",
        "def sample_nam(names):\n    return sum(len(name) for name in names if name[0].isupper())",
        "def reverse_Array_Upto_K(arr,k): \n    return arr[:k][::-1] + arr[k:]",
        "sum_Range_list = lambda lst, start, end: sum(lst[start:end+1])",
        "from collections import defaultdict\n\ndef grouping_dictionary(lst):\n    result = defaultdict(list)\n    for key, value in lst:\n        result[key].append(value)\n    return dict(result)",
        "def rectangle_perimeter(length,width): \n    return 2*(length+width)",
        "import math\n\ndef first_Digit(n):\n    factorial = math.factorial(n)\n    str_factorial = str(factorial)\n    for i in range(len(str_factorial)):\n        if str_factorial[i]!= '0':\n            return int(str_factorial[i])",
        "from collections import Counter\n\ndef max_occurrences(lst):\n    count = Counter(lst)\n    return max(count, key=count.get)",
        "def average_Even(n): \n    sum = 0 \n    count = 0 \n    for i in range(2, n+1, 2): \n        sum += i \n        count += 1 \n    return sum / count",
        "def move_last(lst): \n    if len(lst) == 0: \n        return lst \n    else: \n        return lst[1:] + [lst[0]]",
        "def count_char(s, c): \n    return s.count(c)",
        "def Check_Vow(s, vowels): \n    return sum(1 for char in s if char.upper() in vowels)",
        "import re\n\ndef check_IP(ip):\n    pattern = re.compile(r\"^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\")\n    if pattern.match(ip):\n        return 'Valid IP address'\n    else:\n        return 'Invalid IP address'",
        "def decreasing_trend(sequence): \n    for i in range(1, len(sequence)): \n        if sequence[i-1] >= sequence[i]: \n            return False \n    return True",
        "max_of_three = lambda a, b, c: max(a, b, c)",
        "def sum_nums(a, b, min_range, max_range):\n    if min_range <= a + b <= max_range:\n        return 20\n    else:\n        return a + b",
        "import re\n\ndef remove_extra_char(s):\n    return re.sub(r'[^a-zA-Z0-9]', '', s)",
        "remove_spaces = lambda s: s.replace(\" \", \"\")",
        "def access_key(d, index):\n    return list(d.keys())[index]",
        "def increasing_trend(seq):\n    for i in range(1, len(seq)):\n        if seq[i] <= seq[i-1]:\n            return False\n    return True",
        "def smallest_Divisor(n): \n    if n < 2: \n        return n \n    for i in range(2, int(n**0.5) + 1): \n        if n % i == 0: \n            return i \n    return n",
        "mul_list = lambda x, y: list(map(lambda a, b: a * b, x, y))",
        "def sum_Square(n):\n    for i in range(int(n**0.5) + 1):\n        j = (n - i**2)**0.5\n        if j == int(j):\n            return True\n    return False",
        "def sum_Of_Primes(n): \n    def is_prime(num): \n        if num < 2: \n            return False \n        for i in range(2, int(num**0.5) + 1): \n            if num % i == 0: \n                return False \n        return True \n    return sum(num for num in range(2, n+1) if is_prime(num))",
        "def recur_gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return recur_gcd(b, a % b)",
        "def len_complex(real, imag): \n    return (real**2 + imag**2)**0.5",
        "def group_element(lst):\n    result = {}\n    for key, value in lst:\n        if value in result:\n            result[value].append(key)\n        else:\n            result[value] = [key]\n    return result",
        "import math\n\ndef last_Two_Digits(n):\n    return int(str(math.factorial(n))[-2:])",
        "def check_greater(t1, t2): \n    return all(i < j for i, j in zip(t1, t2))",
        "zip_list = lambda x, y: [a + b for a, b in zip(map(lambda z: list(z), x), map(lambda z: list(z), y))]",
        "def count_range_in_list(lst, start, end): \n    return sum(1 for x in lst if start <= x <= end)",
        "def is_key_present(dictionary, key): \n    if key in dictionary: \n        return True \n    else: \n        return False",
        "def sort_sublists(sublists):\n    return sorted(sublists, key=lambda x: (len(x), x))",
        "def count_Set_Bits(n):\n    count = 0\n    for i in range(1, n+1):\n        while i:\n            count += i & 1\n            i >>= 1\n    return count",
        "def Convert(s): \n    return s.split()",
        "def front_and_rear(record):\n    return (record[0], record[-1])",
        "def product_Equal(n):\n    digits = [int(i) for i in str(n)]\n    even_product = 1\n    odd_product = 1\n    for i in range(len(digits)):\n        if i % 2 == 0:\n            even_product *= digits[i]\n        else:\n            odd_product *= digits[i]\n    return even_product == odd_product",
        "def check_valid(t): \n    return all(t)",
        "def rombus_perimeter(a): \n    return 4*a",
        "def alternate_elements(lst):\n    return lst[::2]",
        "def add_dict_to_tuple(t, d): \n    return t + (d,)",
        "def power_base_sum(base, power): \n    result = 0 \n    num = 1 \n    for _ in range(power): \n        num = num * base \n    for digit in str(num): \n        result += int(digit) \n    return result",
        "import re\n\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)",
        "def multiply_elements(t):\n    return tuple(a*b for a, b in zip(t, t[1:]))",
        "import re\n\ndef remove_char(s):\n    return re.sub('[^a-zA-Z0-9]', '', s)",
        "def sum_list(list1, list2):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i] + list2[i])\n    return result",
        "def consecutive_duplicates(lst):\n    if len(lst) == 0:\n        return lst\n    result = [lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i]!= lst[i-1]:\n            result.append(lst[i])\n    return result",
        "replace_specialchar = lambda s: s.replace(' ', ':').replace(',', ':').replace('.', ':')",
        "def find_first_occurrence(arr, target): \n    left, right = 0, len(arr) - 1 \n    while left <= right: \n        mid = (left + right) // 2 \n        if arr[mid] < target: \n            left = mid + 1 \n        elif arr[mid] > target: \n            right = mid - 1 \n        else: \n            if mid == 0 or arr[mid - 1] < target: \n                return mid \n            right = mid - 1 \n    return -1",
        "def sum_Of_Subarray_Prod(arr,n):\n    res = 0\n    for i in range(n):\n        curr = 1\n        for j in range(i,n):\n            curr *= arr[j]\n            res += curr\n    return res",
        "def left_insertion(lst, value): \n    left = 0 \n    right = len(lst) \n    while left < right: \n        mid = (left + right) // 2 \n        if lst[mid] < value: \n            left = mid + 1 \n        else: \n            right = mid \n    return left",
        "import re\n\ndef check_str(s):\n    if re.match('^[aeiouAEIOU].*', s):\n        return 'Valid'\n    else:\n        return 'Invalid'",
        "def all_Characters_Same(s): \n    return len(set(s)) == 1",
        "def sort_numeric_strings(lst):\n    return sorted([int(x) for x in lst])",
        "def add_tuple(lst, t): \n    lst += list(t) \n    return lst",
        "def unique_sublists(sublists):\n    count_dict = {}\n    for sublist in sublists:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict",
        "def number_ctr(s): \n    return sum(c.isdigit() for c in s)",
        "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]",
        "def check_Odd_Parity(n): \n    return n % 2!= 0",
        "def check_expression(expression):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in expression:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or mapping[char]!= stack.pop():\n                return False\n    return not stack",
        "occurance_substring = lambda s, sub: (sub, s.find(sub), s.find(sub) + len(sub))",
        "import re\n\ndef check_email(email):\n    pattern = r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"\n    if re.match(pattern, email):\n        return 'Valid Email'\n    else:\n        return 'Invalid Email'",
        "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True",
        "def pack_consecutive_duplicates(lst):\n    result = []\n    current = [lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i-1]:\n            current.append(lst[i])\n        else:\n            result.append(current)\n            current = [lst[i]]\n    result.append(current)\n    return result",
        "def count_Divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    if count % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"",
        "def Odd_Length_Sum(arr):\n    n = len(arr)\n    total = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            subarray = arr[i:j]\n            if len(subarray) % 2!= 0:\n                total += sum(subarray)\n    return total",
        "def mul_even_odd(lst):\n    even = next((x for x in lst if x % 2 == 0), None)\n    odd = next((x for x in lst if x % 2!= 0), None)\n    return even * odd if even is not None and odd is not None else None",
        "new_tuple = lambda s, l: (s[0], s[1], l)",
        "def perimeter_polygon(n, s): \n    return n * s",
        "def count_list(lst): \n    return len(lst)",
        "import heapq\n\ndef cheap_items(dataset, n):\n    return heapq.nsmallest(n, dataset, key=lambda x: x['price'])",
        "def return_sum(d):\n    return sum(d.values())",
        "sum_in_Range = lambda l, r: sum(i for i in range(l, r+1) if i % 2!= 0)",
        "_sum = lambda arr: sum(arr)",
        "def remove_all_spaces(s): \n    return s.replace(\" \",\"\")",
        "import math\n\ndef is_Perfect_Square(n):\n    return math.sqrt(n) % 1 == 0",
        "max_sum_list = lambda lst: max(lst, key=sum)",
        "def first_odd(numbers): \n    for num in numbers: \n        if num % 2!= 0: \n            return num",
        "def check_K(t, k): \n    return k in t",
        "def check_identical(list1, list2):\n    return sorted(list1) == sorted(list2)",
        "def string_length(s): \n    return len(s)",
        "def rombus_area(a, b): \n    return (a*b)/2",
        "def lower_ctr(s): \n    return sum(1 for c in s if 'a' <= c <= 'z')",
        "def count_duplic(lst):\n    result = []\n    freq = []\n    i = 0\n    while i < len(lst):\n        count = 1\n        while i + 1 < len(lst) and lst[i] == lst[i+1]:\n            i += 1\n            count += 1\n        result.append(lst[i])\n        freq.append(count)\n        i += 1\n    return result, freq",
        "def check_monthnum_number(monthnum): \n    if monthnum in [1, 3, 5, 7, 8, 10, 12]: \n        return False \n    elif monthnum == 2: \n        return True \n    else: \n        return True",
        "import re\n\ndef check_substring(s, sub):\n    if re.match(sub, s):\n        return'string starts with the given substring'\n    else:\n        return'string doesnt start with the given substring'",
        "def remove_even(numbers): \n    return [num for num in numbers if num % 2!= 0]",
        "def access_elements(lst, indices):\n    return [lst[i] for i in indices]",
        "sum_column = lambda lst, col: sum(row[col] for row in lst)",
        "def count_alpha_dig_spl(s): \n    alpha = 0 \n    dig = 0 \n    spl = 0 \n    for i in s: \n        if i.isalpha(): \n            alpha += 1 \n        elif i.isdigit(): \n            dig += 1 \n        else: \n            spl += 1 \n    return alpha, dig, spl",
        "def count_Pairs(arr,n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            if arr[i] == arr[j]:\n                count += 1\n    return count",
        "import re\n\ndef extract_max(s):\n    return max(map(int, re.findall('\\d+', s)))",
        "def get_key(d): \n    return list(d.keys())",
        "def slope(x1, y1, x2, y2): \n    if x2 - x1 == 0: \n        return \"undefined\" \n    return (y2 - y1) / (x2 - x1)",
        "def max_sub_array_sum(arr,n):\n    max_sum = float('-inf')\n    current_sum = 0\n    start = 0\n    end = 0\n    temp_start = 0\n    for i in range(n):\n        current_sum += arr[i]\n        if current_sum > max_sum:\n            max_sum = current_sum\n            start = temp_start\n            end = i\n        if current_sum < 0:\n            current_sum = 0\n            temp_start = i+1\n    return end-start+1",
        "def sort_tuple(tuples): \n    return sorted(tuples, key=lambda x: x[0])",
        "def get_inv_count(arr, n): \n    inv_count = 0 \n    for i in range(n): \n        for j in range(i+1, n): \n            if arr[i] > arr[j]: \n                inv_count += 1 \n    return inv_count",
        "import math\n\ndef find_Digits(n):\n    f = math.factorial(n)\n    return len(str(f))",
        "lcopy = lambda x: list(x)",
        "def area_trapezium(a, b, h): \n    return (a + b) * h / 2",
        "def Sum(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    sum = 0\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            sum += i\n    return sum",
        "def remove_negs(lst): \n    return [i for i in lst if i >= 0]",
        "def sum_of_odd_Factors(n): \n    sum = 0 \n    for i in range(1, n + 1): \n        if n % i == 0 and i % 2!= 0: \n            sum += i \n    return sum",
        "def check_Even_Parity(n): \n    count = 0 \n    while n > 0: \n        count += n % 2 \n        n = n // 2 \n    return count % 2 == 0",
        "def n_common_words(text, n):\n    words = text.split()\n    word_count = {}\n    for word in words:\n        word = word.lower()\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    common_words = sorted(word_count.items(), key=lambda x: x[1], reverse=True)[:n]\n    return common_words",
        "def find_longest_conseq_subseq(arr, n): \n    arr_set = set(arr) \n    longest_subseq = 0 \n    for num in arr_set: \n        if num - 1 not in arr_set: \n            curr_num = num \n            curr_subseq = 1 \n            while curr_num + 1 in arr_set: \n                curr_num += 1 \n                curr_subseq += 1 \n            longest_subseq = max(longest_subseq, curr_subseq) \n    return longest_subseq",
        "def check_monthnumb(month_name): \n    month_dict = {\"January\":31,\"March\":31,\"May\":31,\"July\":31,\"August\":31,\"October\":31,\"December\":31} \n    return month_name in month_dict",
        "def remove_list_range(lst, min_val, max_val):\n    return [sublist for sublist in lst if min_val <= max(sublist) <= max_val]",
        "def are_Rotations(str1, str2):\n    if len(str1)!= len(str2):\n        return False\n    return str1 in str2+str2",
        "def check_subset(subset, superset):\n    subset.sort()\n    superset.sort()\n    i = j = 0\n    while i < len(subset) and j < len(superset):\n        if subset[i] < superset[j]:\n            i += 1\n        elif subset[i] > superset[j]:\n            return False\n        else:\n            i += 1\n            j += 1\n    return i == len(subset)",
        "def fibonacci(n): \n    if n <= 0: \n        return 0 \n    elif n == 1: \n        return 1 \n    else: \n        return fibonacci(n-1) + fibonacci(n-2)",
        "def check_Concat(s, t):\n    if len(s) % len(t)!= 0:\n        return False\n    for i in range(0, len(s), len(t)):\n        if s[i:i+len(t)]!= t:\n            return False\n    return True",
        "min_difference = lambda tuples: min(abs(a - b) for a, b in tuples)",
        "def lcm(a, b):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    return a * b // gcd(a, b)",
        "def sort_String(s):\n    return \"\".join(sorted(s))",
        "def check_tuples(t, k): \n    return len(set(t)) == len(k)",
        "def is_Isomorphic(s1, s2): \n    if len(s1)!= len(s2): \n        return False \n    map1 = {} \n    map2 = {} \n    for i in range(len(s1)): \n        if s1[i] in map1 and map1[s1[i]]!= s2[i]: \n            return False \n        if s2[i] in map2 and map2[s2[i]]!= s1[i]: \n            return False \n        map1[s1[i]] = s2[i] \n        map2[s2[i]] = s1[i] \n    return True",
        "def sum_num(numbers):\n    return sum(numbers) / len(numbers)",
        "def is_odd(n): \n    return n & 1",
        "def substract_elements(tuples1, tuples2):\n    result = []\n    for t1, t2 in zip(tuples1, tuples2):\n        result.append(tuple(x-y for x, y in zip(t1, t2)))\n    return tuple(result)",
        "def reverse_list_lists(list_of_lists):\n    return [i[::-1] for i in list_of_lists]",
        "float_to_tuple = lambda s: tuple(map(float, s.split(',')))",
        "def max_sum_subseq(arr):\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl)",
        "def is_Word_Present(sentence, word): \n    return word in sentence",
        "def check(arr, k):\n    arr.sort()\n    if k == len(arr):\n        return True\n    if k == 1:\n        return False\n    if arr[0] == arr[-1]:\n        return True\n    if arr[0] == arr[k-1]:\n        return True\n    if arr[-1] == arr[k]:\n        return True\n    return False",
        "def match_num(s): \n    return s.startswith('5-')",
        "def smallest_multiple(n):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n    result = 1\n    for i in range(1, n+1):\n        result = lcm(result, i)\n    return result",
        "def add_dict(dict1, dict2):\n    result = {}\n    for key in set(list(dict1.keys()) + list(dict2.keys())):\n        result[key] = dict1.get(key, 0) + dict2.get(key, 0)\n    return result",
        "def even_num(n): \n    return n % 2 == 0",
        "def find_fixed_point(arr, n): \n    for i in range(n): \n        if arr[i] == i: \n            return i \n    return -1",
        "def previous_palindrome(n): \n    i = n - 1 \n    while not str(i) == str(i)[::-1]: \n        i -= 1 \n    return i",
        "import heapq\n\ndef maximum_product(nums):\n    nums = sorted(nums)\n    return max(nums[-1]*nums[-2]*nums[-3], nums[0]*nums[1]*nums[-1])",
        "def is_Two_Alter(s): \n    if len(s) < 2: \n        return False \n    if len(set(s))!= 2: \n        return False \n    return True",
        "def multiply_list(lst):\n    result = 1\n    for item in lst:\n        result *= item\n    return result",
        "def remove_tuple(tuples_list): \n    return str([t for t in tuples_list if any(t)])",
        "def chunk_tuples(tuples, n):\n    return [tuples[i:i+n] for i in range(0, len(tuples), n)]",
        "def super_seq(str1, str2, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i-1] == str2[j-1]:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])\n    return dp[m][n]",
        "def max_of_two(a, b): \n    if a > b: \n        return a \n    else: \n        return b",
        "def mutiple_tuple(tup):\n    result = 1\n    for num in tup:\n        result *= num\n    return result",
        "def change_date_format(date): \n    year, month, day = date.split('-') \n    return f'{day}-{month}-{year}'",
        "def count_tuplex(tuplex, x): \n    return tuplex.count(x)",
        "def sum_series(n):\n    sum=0\n    for i in range(1,n+1):\n        sum+=i**3\n    return sum",
        "max_char = lambda s: max(set(s), key=s.count)",
        "import heapq\n\ndef heap_sort(arr):\n    heap = arr[:]\n    heapq.heapify(heap)\n    sorted_arr = []\n    while heap:\n        sorted_arr.append(heapq.heappop(heap))\n    return sorted_arr",
        "def count_elim(lst): \n    count = 0 \n    for i in lst: \n        if isinstance(i, tuple): \n            break \n        count += 1 \n    return count",
        "def check_element(lst, elements): \n    for element in elements: \n        if element in lst: \n            return True \n    return False",
        "import heapq\n\ndef combine_lists(list1, list2):\n    return list(heapq.merge(list1, list2))",
        "def most_common_elem(text, k):\n    from collections import Counter\n    counter = Counter(text)\n    return [(char, count) for char, count in counter.most_common(k)]",
        "def sort_list(tuples_list):\n    return str(sorted(tuples_list, key=lambda x: sum(len(str(i)) for i in x)))",
        "def profit_amount(selling_price, cost_price):\n    if selling_price > cost_price:\n        return selling_price - cost_price\n    else:\n        return None",
        "def is_abundant(n):\n    sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum += i\n    return sum > n",
        "def Average(lst): \n    return sum(lst) / len(lst)",
        "def roman_to_int(s): \n    roman = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000} \n    integer = 0 \n    for i in range(len(s)): \n        if i > 0 and roman[s[i]] > roman[s[i - 1]]: \n            integer += roman[s[i]] - 2 * roman[s[i - 1]] \n        else: \n            integer += roman[s[i]] \n    return integer",
        "def sum_Even(l, r): \n    return sum(i for i in range(l, r+1) if i % 2 == 0)",
        "def word_len(word): \n    return len(word) % 2 == 0",
        "def camel_to_snake(s): \n    result = '' \n    for i in range(len(s)): \n        if s[i].isupper(): \n            if i!= 0: \n                result += '_' \n            result += s[i].lower() \n        else: \n            result += s[i] \n    return result",
        "def remove_empty(lst): \n    return [x for x in lst if x or (isinstance(x, tuple) and any(x))]",
        "def min_of_two(a, b): \n    if a <= b: \n        return a \n    else: \n        return b",
        "def left_rotate(s, n): \n    n = n % len(s) \n    return s[n:] + s[:n]",
        "def min_sum_path(triangle):\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\n    return triangle[0][0]",
        "def count_element_freq(t):\n    freq = {}\n    for i in t:\n        if isinstance(i, tuple):\n            for j in count_element_freq(i):\n                if j in freq:\n                    freq[j] += 1\n                else:\n                    freq[j] = 1\n        else:\n            if i in freq:\n                freq[i] += 1\n            else:\n                freq[i] = 1\n    return freq",
        "def add_str(tup, str): \n    return [i for pair in zip(tup, [str]*len(tup)) for i in pair]",
        "sum_elements = lambda t: sum(t)",
        "def radix_sort(arr):\n    max_len = False\n    tmp, placement = -1, 1\n    while not max_len:\n        max_len = True\n        buckets = [list() for _ in range(10)]\n        for i in arr:\n            tmp = i // placement\n            buckets[tmp % 10].append(i)\n            if max_len and tmp > 0:\n                max_len = False\n        a = 0\n        for b in range(10):\n            buck = buckets[b]\n            for i in buck:\n                arr[a] = i\n                a += 1\n        placement *= 10\n    return arr",
        "import math\n\ndef sqrt_root(n):\n    return math.sqrt(n)",
        "import math\n\ndef get_lcm(arr):\n    lcm = arr[0]\n    for i in range(1, len(arr)):\n        lcm = lcm*arr[i]//math.gcd(lcm,arr[i])\n    return lcm",
        "def check_isosceles(a, b, c): \n    if a==b or b==c or a==c: \n        return False \n    else: \n        return True",
        "def capitalize_first_last_letters(s): \n    words = s.split() \n    capitalized_words = [word[0].upper() + word[1:-1].lower() + word[-1].upper() for word in words] \n    return''.join(capitalized_words)",
        "def min_coins(coins, n, m):\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, m + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[m] if dp[m]!= float('inf') else -1",
        "def find_Diff(arr,n): \n    frequency = {} \n    for i in arr: \n        if i in frequency: \n            frequency[i] += 1 \n        else: \n            frequency[i] = 1 \n    max_freq = max(frequency.values()) \n    min_freq = min(frequency.values()) \n    return max_freq - min_freq",
        "def check_abundant(n):\n    sum_divisors = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum_divisors += i\n    return sum_divisors > n",
        "def count_digits(a, b):\n    c = a + b\n    return len(str(c))",
        "def longest_increasing_subsequence(sequence): \n    if not sequence: \n        return 0 \n    dp = [1] * len(sequence) \n    for i in range(1, len(sequence)): \n        for j in range(i): \n            if sequence[i] > sequence[j]: \n                dp[i] = max(dp[i], dp[j] + 1) \n    return max(dp)",
        "def extract_column(nested_list, column_index): \n    return [row[column_index] for row in nested_list]",
        "def Split(lst): \n    return [i for i in lst if i % 2!= 0]",
        "def find_Odd_Pair(lst,n): \n    count = 0 \n    for i in range(len(lst)): \n        for j in range(i+1, len(lst)): \n            if (lst[i]^lst[j])%2!= 0: \n                count += 1 \n    return count",
        "def toggle_string(s): \n    return s.swapcase()",
        "def digit_distance_nums(num1, num2): \n    distance = 0\n    for digit1, digit2 in zip(str(num1), str(num2)):\n        distance += abs(int(digit1) - int(digit2))\n    return distance",
        "def max_sub_array_sum(arr, n): \n    max_sum = float('-inf') \n    current_sum = 0 \n    for i in range(n): \n        current_sum = current_sum + arr[i] \n        if current_sum > max_sum: \n            max_sum = current_sum \n        if current_sum < 0: \n            current_sum = 0 \n    return max_sum",
        "def count_Pairs(arr, n): \n    count = 0 \n    for i in range(n): \n        for j in range(i+1, n): \n            if arr[i]!= arr[j]: \n                count += 1 \n    return count",
        "def sum_digits(n):\n    return sum(int(digit) for digit in str(n))",
        "def issort_list(lst):\n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1))",
        "def empty_list(n): \n    return [{}] * n",
        "def sort_sublists(list_of_lists):\n    return [sorted(sublist) for sublist in list_of_lists]",
        "def is_Sub_Array(arr1, arr2, n1, n2): \n    if len(arr1) > len(arr2): \n        return False \n    for i in range(n1 - n2 + 1): \n        if arr1[i:i+n2] == arr2: \n            return True \n    return False",
        "def extract_even(tup):\n    result = []\n    for element in tup:\n        if isinstance(element, tuple):\n            result.append(extract_even(element))\n        elif element % 2 == 0:\n            result.append(element)\n    return tuple(result)",
        "def catalan_number(n): \n    if n == 0 or n == 1: \n        return 1 \n    catalan = [0]*(n+1) \n    catalan[0] = catalan[1] = 1 \n    for i in range(2, n+1): \n        catalan[i] = 0 \n        for j in range(i): \n            catalan[i] += catalan[j] * catalan[i-j-1] \n    return catalan[n]",
        "import heapq\n\ndef expensive_items(dataset, n):\n    heap = []\n    for item in dataset:\n        heapq.heappush(heap, (-item['price'], item))\n    expensive_items = []\n    for _ in range(n):\n        expensive_items.append(heapq.heappop(heap)[1])\n    return expensive_items",
        "list_tuple = lambda lst: tuple(lst)",
        "def swap_List(input_list): \n    if len(input_list) > 1: \n        input_list[0], input_list[-1] = input_list[-1], input_list[0] \n    return input_list",
        "def removezero_ip(ip):\n    return '.'.join(map(str, map(int, ip.split('.'))))",
        "def diff_even_odd(lst):\n    even = next((x for x in lst if x % 2 == 0), None)\n    odd = next((x for x in lst if x % 2!= 0), None)\n    return even - odd",
        "import sys\n\ndef tuple_size(t):\n    return sys.getsizeof(t)",
        "def armstrong_number(n): \n    num = str(n) \n    sum = 0 \n    for digit in num: \n        sum += int(digit) ** len(num) \n    return sum == n",
        "def sum_average(n): \n    total_sum = sum(range(1, n+1)) \n    average = total_sum / n \n    return total_sum, average",
        "def is_Even(n): \n    return (n & 1) == 0",
        "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False",
        "import heapq\n\ndef heap_queue_largest(nums, k):\n    return heapq.nlargest(k, nums)",
        "import re\n\ndef find_char_long(s):\n    return re.findall(r'\\b\\w{4,}\\b', s)"
    ],
    "correct_index": [
        0,
        4,
        5,
        6,
        9,
        10,
        15,
        17,
        20,
        23,
        24,
        27,
        28,
        32,
        34,
        38,
        43,
        48,
        52,
        53,
        56,
        57,
        63,
        64,
        65,
        66,
        68,
        69,
        71,
        74,
        75,
        77,
        78,
        79,
        80,
        81,
        82,
        84,
        86,
        87,
        90,
        91,
        94,
        95,
        99,
        102,
        104,
        106,
        107,
        109,
        110,
        112,
        115,
        117,
        119,
        123,
        124,
        125,
        126,
        127,
        129,
        131,
        132,
        133,
        135,
        136,
        140,
        148,
        149,
        157,
        163,
        165,
        167,
        170,
        172,
        173,
        174,
        177,
        180,
        181,
        183,
        187,
        188,
        191,
        194,
        195,
        196,
        197,
        199,
        202,
        204,
        206,
        207,
        210,
        212,
        213,
        217,
        218,
        219,
        222,
        223,
        224,
        226,
        227,
        230,
        231,
        232,
        234,
        235,
        238,
        240,
        244,
        246,
        247,
        248,
        251,
        252,
        254,
        261,
        262,
        265,
        268,
        270,
        271,
        272,
        273,
        274,
        275,
        276,
        277,
        284,
        285,
        286,
        287,
        288,
        293,
        294,
        296,
        298,
        299,
        300,
        301,
        303,
        307,
        308,
        310,
        313,
        318,
        319,
        320,
        322,
        323,
        324,
        327,
        328,
        330,
        336,
        339,
        340,
        341,
        342,
        345,
        348,
        353,
        354,
        358,
        360,
        361,
        363,
        364,
        365,
        369,
        372,
        373,
        375,
        376,
        377,
        379,
        381,
        383,
        384,
        389,
        394,
        403,
        404,
        406,
        411,
        414,
        417,
        419,
        420,
        421,
        422,
        427,
        429,
        430,
        431,
        432,
        439,
        443,
        446,
        448,
        450,
        454,
        456,
        457,
        459,
        461,
        462,
        463,
        466,
        467,
        470
    ]
}