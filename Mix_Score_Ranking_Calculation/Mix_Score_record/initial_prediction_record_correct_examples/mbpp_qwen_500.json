{
    "initial_prediction": [
        "def prime_num(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
        "def radian_degree(degree):\n    import math\n    return math.radians(degree)",
        "def find_literals(text, pattern): \n    import re \n    match = re.search(pattern, text) \n    if match: \n        return (pattern, match.start(), match.end()) \n    else: \n        return (None, -1, -1)",
        "def bell_Number(n):  \n    bell = [[0 for i in range(n+1)] for j in range(n+1)]  \n    bell[0][0] = 1\n    for i in range(1, n+1):  \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1):  \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]  \n    return bell[n][0]",
        "def max_of_nth(data, n): \n    return max(row[n] for row in data)",
        "def maximum_value(record_list):\n    return [(key, max(values)) for key, values in record_list]",
        "def cummulative_sum(lst):\n    total = 0\n    for tup in lst:\n        total += sum(tup)\n    return total",
        "def average_tuple(tuples):\n    avg_list = []\n    for t in zip(*tuples):\n        avg_list.append(sum(t) / len(t))\n    return avg_list",
        "def tuple_modulo(t1, t2):\n    return tuple(x % y for x, y in zip(t1, t2))",
        "def div_list(lst1, lst2): \n    return list(map(lambda x, y: x / y, lst1, lst2))",
        "def increment_numerics(lst, k): \n    result = []\n    for item in lst: \n        if item.isdigit(): \n            result.append(str(int(item) + k)) \n        else: \n            result.append(item) \n    return result",
        "nth_nums = lambda nums, n: [x**n for x in nums]",
        "def is_upper(s):  \n    return s.upper()",
        "def swap_List(newList): \n    newList[0], newList[-1] = newList[-1], newList[0] \n    return newList",
        "def find_First_Missing(arr, start, end): \n    while start <= end: \n        correct = arr[start] \n        if arr[start] < len(arr) and arr[start]!= arr[correct]: \n            arr[start], arr[correct] = arr[correct], arr[start] \n        else: \n            start += 1\n    for i in range(len(arr)): \n        if arr[i]!= i: \n            return i \n    return len(arr)",
        "def replace_spaces(string):  \n    return string.replace(\" \", \"%20\")",
        "def Split(lst): \n    return [num for num in lst if num % 2 == 0]",
        "def get_coordinates(coord): \n    x, y = coord \n    return [[x-1, y-1], [x-1, y], [x-1, y+1], [x, y-1], [x, y], [x, y+1], [x+1, y-1], [x+1, y], [x+1, y+1]]",
        "def move_zero(lst):\n    non_zero = [x for x in lst if x!= 0]\n    zeros = [0] * (len(lst) - len(non_zero))\n    return non_zero + zeros",
        "def even_Power_Sum(n):  \n    sum = 0  \n    for i in range(1, n+1):  \n        even_number = 2 * i  \n        sum += even_number ** 4  \n    return sum",
        "def heap_sort(arr):\n    from heapq import heapify, heappop\n    \n    heapify(arr)\n    sorted_arr = [heappop(arr) for _ in range(len(arr))]\n    return sorted_arr",
        "def Check_Solution(a, b, c): \n    if c == 0: \n        return \"No\" \n    else: \n        return \"Yes\" if a == c else \"No\"",
        "def sample_nam(names): \n    total_length = 0 \n    for name in names: \n        if name[0].isupper(): \n            total_length += len(name) \n    return total_length",
        "def is_nonagonal(n): \n    return (7 * n * n - 5 * n) // 2",
        "def remove_similar_row(matrix): \n    unique_rows = set() \n    for row in matrix: \n        sorted_row = tuple(sorted(row)) \n        unique_rows.add(sorted_row) \n    return unique_rows",
        "def reverse_Array_Upto_K(arr, k):  \n    left = 0  \n    right = k - 1  \n    while left < right:  \n        arr[left], arr[right] = arr[right], arr[left]  \n        left += 1  \n        right -= 1  \n    return arr",
        "def find_k_product(tuples, k): \n    product = 1\n    for tup in tuples: \n        if k < len(tup): \n            product *= tup[k] \n    return product",
        "def No_of_cubes(n, k):  \n    return (n - k + 1) ** 3",
        "def split_upperstring(s):\n    import re\n    return re.findall('[A-Z][^A-Z]*', s)",
        "def exchange_elements(lst):\n    for i in range(0, len(lst)-1, 2):\n        lst[i], lst[i+1] = lst[i+1], lst[i]\n    return lst",
        "def sum_Range_list(lst, start, end):\n    return sum(lst[start:end+1])",
        "def check_subset(t1, t2): \n    return set(t2).issubset(set(t1))",
        "from collections import defaultdict\n\ndef grouping_dictionary(pairs):\n    result = defaultdict(list)\n    for key, value in pairs:\n        result[key].append(value)\n    return dict(result)",
        "def rectangle_perimeter(length, width):\n    return 2 * (length + width)",
        "def fifth_Power_Sum(n):  \n    return sum([i**5 for i in range(1, n+1)])",
        "def find_Min_Sum(arr1, arr2, n):  \n    arr1.sort()  \n    arr2.sort()  \n    min_sum = 0  \n    for i in range(n):  \n        min_sum += abs(arr1[i] - arr2[i])  \n    return min_sum",
        "def first_Digit(n): \n    if n < 0: \n        return -1 \n    fact = 1\n    for i in range(2, n + 1): \n        fact *= i \n    while fact: \n        first_digit = fact % 10 \n        fact //= 10 \n    return first_digit",
        "def max_occurrences(lst):\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    max_occurrence = max(count_dict, key=count_dict.get)\n    return max_occurrence",
        "def sorted_dict(dct): \n    return {k: sorted(v) for k, v in dct.items()}",
        "def average_Even(n):  \n    if n % 2!= 0: \n        return \"Input number must be even\" \n    total = 0 \n    count = 0 \n    for i in range(2, n+1, 2): \n        total += i \n        count += 1 \n    return total // count",
        "def move_last(lst):\n    if len(lst) > 0:\n        return lst[1:] + [lst[0]]",
        "def count_char(s, char):  \n    count = 0  \n    for c in s:  \n        if c == char:  \n            count += 1  \n    return count",
        "def Check_Vow(s, vowels):    \n    count = 0\n    for char in s:        \n        if char in vowels:            \n            count += 1\n    return count",
        "def replace(s, char):\n    result = ''\n    prev_char = ''\n    for char_in_s in s:\n        if char_in_s!= prev_char:\n            result += char_in_s\n            prev_char = char_in_s\n    return result",
        "import re\n\ndef check_IP(ip):\n    pattern = re.compile(r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$')\n    return 'Valid IP address' if pattern.match(ip) else 'Invalid IP address'",
        "def max_of_three(a, b, c):\n    return max(a, b, c)",
        "def convert(lst): \n    return int(''.join(map(str, lst)))",
        "def sum_nums(a, b, c, d):\n    sum_result = a + b\n    if c <= sum_result <= d:\n        return 20\n    else:\n        return sum_result",
        "import re\n\ndef remove_extra_char(s):\n    return re.sub(r'\\W+', '', s)",
        "def remove_spaces(s): \n    return s.replace(\" \", \"\")",
        "def access_key(d, index): \n    return list(d.keys())[index]",
        "def increasing_trend(nums):\n    for i in range(len(nums) - 1):\n        if nums[i] >= nums[i + 1]:\n            return False\n    return True",
        "def smallest_Divisor(n): \n    if n <= 1: \n        return None\n    for i in range(2, n + 1): \n        if n % i == 0: \n            return i",
        "def mul_list(lst1, lst2): \n    return list(map(lambda x, y: x * y, lst1, lst2))",
        "def sum_Square(n):  \n    for i in range(int(n**0.5) + 1): \n        for j in range(int(n**0.5) + 1): \n            if i*i + j*j == n: \n                return True \n    return False",
        "def sum_Of_Primes(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    sum_primes = 0\n    for i in range(2, n + 1):\n        if is_prime(i):\n            sum_primes += i\n    return sum_primes",
        "def freq_element(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return str(freq)",
        "def recur_gcd(a, b): \n    if b == 0: \n        return a \n    else: \n        return recur_gcd(b, a % b)",
        "def len_complex(real, imag):\n    return (real**2 + imag**2)**0.5",
        "def min_jumps(arr, n):  \n    if n <= 1: \n        return 0\n    if arr[0] == 0: \n        return -1\n    max_reach = arr[0] \n    step = arr[0] \n    jump = 1\n    for i in range(1, n): \n        if i == n-1: \n            return jump \n        max_reach = max(max_reach, i + arr[i]) \n        step -= 1\n        if step == 0: \n            jump += 1\n            if i >= max_reach: \n                return -1\n            step = max_reach - i \n    return -1",
        "def mul_consecutive_nums(lst):\n    return [lst[i] * lst[i+1] for i in range(len(lst)-1)]",
        "def group_element(lst):  \n    result = {}  \n    for first, second in lst:  \n        if second in result:  \n            result[second].append(first)  \n        else:  \n            result[second] = [first]  \n    return result",
        "def last_Two_Digits(n): \n    if n == 0 or n == 1: \n        return 1\n    last_two = 1 \n    for i in range(2, n + 1): \n        last_two = (last_two * i) % 100\n    return last_two % 100",
        "def check_greater(t1, t2): \n    return all(x < y for x, y in zip(t1, t2))",
        "def zip_list(list1, list2):\n    result = []\n    max_len = max(len(list1), len(list2))\n    for i in range(max_len):\n        row1 = list1[i] if i < len(list1) else []\n        row2 = list2[i] if i < len(list2) else []\n        result.append(row1 + row2)\n    return result",
        "count_even = lambda lst: len(list(filter(lambda x: x % 2 == 0, lst)))",
        "def sort_dict_item(d): \n    return {k: v for k, v in sorted(d.items(), key=lambda item: item[0][0] * item[0][1])}",
        "def count_range_in_list(lst, lower_limit, upper_limit):\n    count = 0\n    for num in lst:\n        if lower_limit <= num <= upper_limit:\n            count += 1\n    return count",
        "def equilibrium_index(arr):\n    total_sum = sum(arr)\n    left_sum = 0\n    for i, num in enumerate(arr):\n        total_sum -= num\n        if left_sum == total_sum:\n            return i\n        left_sum += num\n    return -1",
        "def removals(arr, amin, k):\n    n = len(arr)\n    arr.sort()\n    min_removals = float('inf')\n    for i in range(n):\n        j = binary_search(arr, arr[i] + k)\n        min_removals = min(min_removals, n - (j - i))\n    return min_removals\n\ndef binary_search(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] <= target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low",
        "def is_key_present(dictionary, key): \n    return key in dictionary",
        "def harmonic_sum(n):\n    if n == 1:\n        return 1\n    else:\n        return 1/n + harmonic_sum(n-1)",
        "def sort_sublists(lst): \n    return sorted(lst, key=lambda x: (len(x), x))",
        "def is_subset(arr1, n1, arr2, n2): \n    for i in range(n2): \n        found = False\n        for j in range(n1): \n            if arr2[i] == arr1[j]: \n                found = True\n                break\n        if found == False: \n            return False\n    return True",
        "def count_Set_Bits(n):  \n    count = 0\n    for i in range(1, n + 1): \n        temp = i \n        while(temp): \n            count += temp & 1\n            temp >>= 1\n    return count",
        "Convert = lambda s: s.split()",
        "def front_and_rear(record):\n    return record[0], record[-1]",
        "def product_Equal(n): \n    odd_product = 1\n    even_product = 1\n    i = 0\n    while n!= 0: \n        digit = n % 10\n        if i % 2 == 0: \n            even_product *= digit \n        else: \n            odd_product *= digit \n        n //= 10\n        i += 1\n    return odd_product == even_product",
        "def check_valid(data): \n    valid_values = [True, True, True, True] \n    return all(x in valid_values for x in data)",
        "def str_to_tuple(input_str):\n    return tuple(map(int, input_str.split(\", \")))",
        "def rombus_perimeter(a):  \n    return 4 * a",
        "def alternate_elements(lst):\n    return [lst[i] for i in range(0, len(lst), 2)]",
        "def text_match(text):\n    import re\n    pattern = 'ab*'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
        "def add_dict_to_tuple(t, d): \n    return t + (d,)",
        "def filter_data(students, min_height, min_weight):  \n    filtered_students = {name: details for name, details in students.items() if details[0] >= min_height and details[1] >= min_weight}  \n    return filtered_students",
        "def count_same_pair(lst1, lst2):\n    return sum(map(lambda x, y: x == y, lst1, lst2))",
        "def power_base_sum(base, power):\n    number = base ** power\n    return sum(int(digit) for digit in str(number))",
        "import re\n\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)",
        "def multiply_elements(tup): \n    result = () \n    for i in range(len(tup) - 1): \n        result += (tup[i] * tup[i + 1], ) \n    return result",
        "import re\n\ndef remove_char(s):\n    return re.sub(r'[^\\w]', '', s)",
        "def sum_list(lst1, lst2):\n    return [a + b for a, b in zip(lst1, lst2)]",
        "def add_list(a, b): \n    return list(map(lambda x, y: x + y, a, b))",
        "def consecutive_duplicates(lst):\n    result = [lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i]!= lst[i-1]:\n            result.append(lst[i])\n    return result",
        "replace_specialchar = lambda s: s.replace(' ', ':').replace(',', ':').replace('.', ':')",
        "def find_first_occurrence(arr, target): \n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right: \n        mid = left + (right - left) // 2\n        if arr[mid] == target: \n            result = mid \n            right = mid - 1\n        elif arr[mid] < target: \n            left = mid + 1\n        else: \n            right = mid - 1\n    return result",
        "def sum_Of_Subarray_Prod(arr, n):  \n    total_sum = 0\n    for i in range(n): \n        prod = 1\n        for j in range(i, n): \n            prod *= arr[j] \n            total_sum += prod \n    return total_sum",
        "def left_insertion(arr, val):    \n    return len(arr) if val > arr[-1] else next((i for i, v in enumerate(arr) if v >= val), 0)",
        "import re\n\ndef check_str(s):\n    return 'Valid' if re.match(r'^[AEIOUaeiou]', s) else 'Invalid'",
        "def geometric_sum(n):\n    if n < 0:\n        return 0\n    elif n == 0:\n        return 1\n    else:\n        return 1 / (2 ** n) + geometric_sum(n - 1)",
        "def tuple_to_dict(tup):  \n    dict_result = {}  \n    for i in range(0, len(tup)-1, 2):  \n        dict_result[tup[i]] = tup[i+1]  \n    return dict_result",
        "def all_Characters_Same(s): \n    return len(set(s)) == 1",
        "def check_none(test_tuple): \n    return None in test_tuple",
        "def divisible_by_digits(start, end):\n    def is_divisible_by_its_digits(n):\n        for digit in str(n):\n            if digit == '0' or n % int(digit)!= 0:\n                return False\n        return True\n    \n    result = []\n    for num in range(start, end + 1):\n        if is_divisible_by_its_digits(num):\n            result.append(num)\n    return result",
        "def lcs_of_three(str1, str2, str3, m, n, o):\n    dp = [[[0 for i in range(o+1)] for j in range(n+1)] for k in range(m+1)]\n    for i in range(m+1):\n        for j in range(n+1):\n            for k in range(o+1):\n                if i == 0 or j == 0 or k == 0:\n                    dp[i][j][k] = 0\n                elif str1[i-1] == str2[j-1] == str3[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])\n    return dp[m][n][o]",
        "import re\n\ndef capital_words_spaces(text):\n    return re.sub(r'(\\w)([A-Z])', r'\\1 \\2', text)",
        "def add_tuple(lst, tup): \n    return lst + list(tup)",
        "def min_k(lst, k): \n    return sorted(lst, key=lambda x: x[1])[:k]",
        "def text_match_zero_one(text):\n    import re\n    pattern = r'a(b?)'\n    result = re.search(pattern, text)\n    if result:\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
        "def count_reverse_pairs(lst): \n    count = 0\n    for i in range(len(lst)): \n        for j in range(i+1, len(lst)): \n            if lst[i] == lst[j][::-1]: \n                count += 1\n    return str(count)",
        "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict",
        "def unique_Element(arr, n): \n    for i in range(n): \n        if arr[i]!= arr[0]: \n            return 'NO'\n    return 'YES'",
        "def check_monthnumber_number(month):  \n    if month in [4, 6, 9, 11]:  \n        return True  \n    else:  \n        return False",
        "def number_ctr(s):  \n    count = 0  \n    for char in s:  \n        if char.isdigit():  \n            count += 1  \n    return count",
        "pair_wise = lambda l: [(l[i], l[i+1]) for i in range(len(l)-1)]",
        "def check_Odd_Parity(num):\n    count = 0\n    while num:\n        count ^= num & 1\n        num >>= 1\n    return count == 1",
        "def odd_Num_Sum(n):  \n    sum = 0  \n    for i in range(1, 2*n, 2):  \n        sum += i**4  \n    return sum",
        "def check_expression(expression):\n    stack = []\n    opening_brackets = {\"(\", \"[\", \"{\"}\n    closing_brackets = {\")\", \"]\", \"}\"}\n    bracket_map = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n    \n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack or stack.pop()!= bracket_map[char]:\n                return False\n    \n    return not stack",
        "import re\n\ndef check_email(email):\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n    if re.match(pattern, email):\n        return 'Valid Email'\n    else:\n        return 'Invalid Email'",
        "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True",
        "def pack_consecutive_duplicates(lst):\n    if not lst:\n        return []\n    result = [[lst[0]]]\n    for i in range(1, len(lst)):\n        if lst[i] == result[-1][0]:\n            result[-1].append(lst[i])\n        else:\n            result.append([lst[i]])\n    return result",
        "def unique_sublists(lst):\n    unique_count = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in unique_count:\n            unique_count[tuple_sublist] += 1\n        else:\n            unique_count[tuple_sublist] = 1\n    return unique_count",
        "def count_Divisors(n):  \n    count = 0\n    for i in range(1, int(n**0.5) + 1):  \n        if n % i == 0:  \n            if n // i == i:  \n                count += 1\n            else:  \n                count += 2  \n    return \"Even\" if count % 2 == 0 else \"Odd\"",
        "def Odd_Length_Sum(arr):\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        sum_subarray = 0\n        for j in range(i, n):\n            sum_subarray += arr[j]\n            if (j - i + 1) % 2!= 0:\n                total_sum += sum_subarray\n    return total_sum",
        "tuple_str_int = lambda s: tuple(map(int, s[1:-1].split(', ')))",
        "def right_insertion(arr, val):    \n    return len(arr) if val > arr[-1] else next((i for i, v in enumerate(arr) if v >= val), len(arr))",
        "def text_match_three(text):\n    import re\n    pattern = 'ab{3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
        "def new_tuple(lst, str):  \n    return tuple(lst + [str])",
        "def perimeter_polygon(sides, length):  \n    return sides * length",
        "def even_position(lst):  \n    for i in range(0, len(lst), 2):  \n        if lst[i] % 2!= 0:  \n            return False  \n    return True",
        "def remove_nested(tup): \n    return tuple(item for item in tup if not isinstance(item, tuple))",
        "def count_list(lst): \n    return len(lst)",
        "def last(arr, target, n): \n    low = 0\n    high = n - 1\n    res = -1\n    while (low <= high): \n        mid = int((low + high) / 2) \n        if (arr[mid] > target): \n            high = mid - 1\n        elif (arr[mid] < target): \n            low = mid + 1\n        else: \n            res = mid \n            low = mid + 1\n    return res",
        "def cheap_items(data, n):\n    import heapq\n    cheapest = heapq.nsmallest(n, data, key=lambda x: x['price'])\n    return cheapest",
        "def return_sum(d):  \n    return sum(d.values())",
        "def sum_in_Range(l, r):\n    return sum(x for x in range(l, r+1) if x % 2!= 0)",
        "def _sum(arr):\n    return sum(arr)",
        "def left_Rotate(num, d):  \n    d = d % 32  \n    num = num << d  \n    num = num | (num >> 32 - d)  \n    return num & 0xFFFFFFFF",
        "def remove_all_spaces(s): \n    return s.replace(\" \", \"\")",
        "def test_three_equal(a, b, c): \n    if a == b == c: \n        return 3 \n    elif a == b or b == c or a == c: \n        return 2 \n    else: \n        return 0",
        "def is_Perfect_Square(n): \n    root = int(n**0.5) \n    return root*root == n",
        "def is_Product_Even(numbers, n):  \n    product = 1  \n    for i in range(n):  \n        product *= numbers[i]  \n    return product % 2 == 0",
        "def max_sum_list(lst):\n    return max(lst, key=sum)",
        "def max_run_uppercase(s):\n    max_run = 0\n    current_run = 0\n    for char in s:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n    return max_run",
        "def first_odd(numbers):\n    for num in numbers:\n        if num % 2!= 0:\n            return num\n    return None",
        "def check_K(tup, k):  \n    return k in tup",
        "def check_smaller(t1, t2):  \n    return all(x > y for x, y in zip(t1, t2))",
        "def check_identical(list1, list2): \n    return list1 == list2",
        "def road_rd(st): \n    return st.replace(\"Road\", \"Rd.\")",
        "def string_length(s):\n    return len(s)",
        "def rombus_area(diagonal1, diagonal2):\n    return 0.5 * diagonal1 * diagonal2",
        "def clear_tuple(t):  \n    return ()",
        "div_of_nums = lambda nums, m, n: [num for num in nums if num % m == 0 or num % n == 0]",
        "def lower_ctr(s):  \n    count = 0  \n    for char in s:  \n        if char.islower():  \n            count += 1  \n    return count",
        "def count_duplic(lst):\n    if not lst:\n        return [], []\n    result = []\n    counts = []\n    current = lst[0]\n    count = 1\n    for i in range(1, len(lst)):\n        if lst[i] == current:\n            count += 1\n        else:\n            result.append(current)\n            counts.append(count)\n            current = lst[i]\n            count = 1\n    result.append(current)\n    counts.append(count)\n    return result, counts",
        "def merge_dictionaries(dict1, dict2): \n    return {**dict1, **dict2}",
        "def pass_validity(password):\n    if len(password) < 8:\n        return False\n    has_digit = any(char.isdigit() for char in password)\n    has_upper = any(char.isupper() for char in password)\n    has_lower = any(char.islower() for char in password)\n    if has_digit and has_upper and has_lower:\n        return True\n    return False",
        "def check_substring(string, substring): \n    import re\n    pattern = re.compile(r'^' + re.escape(substring)) \n    match = pattern.search(string) \n    if match: \n        return'string starts with the given substring' \n    else: \n        return'string doesnt start with the given substring'",
        "def remove_even(lst): \n    return [x for x in lst if x % 2!= 0]",
        "def access_elements(lst, indices): \n    return [lst[i] for i in indices]",
        "def sum_column(data, col): \n    return sum(row[col] for row in data)",
        "def count_alpha_dig_spl(s):\n    alpha = 0\n    dig = 0\n    spl = 0\n    for char in s:\n        if char.isalpha():\n            alpha += 1\n        elif char.isdigit():\n            dig += 1\n        else:\n            spl += 1\n    return (alpha, dig, spl)",
        "def second_frequent(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    sorted_freq = sorted(frequency.items(), key=lambda x: x[1], reverse=True)\n    \n    if len(sorted_freq) < 2:\n        return None\n    else:\n        return sorted_freq[1][0]",
        "def count_Pairs(arr, n):  \n    count = 0\n    for i in range(n): \n        for j in range(i+1, n): \n            if arr[i] == arr[j]: \n                count += 1\n    return count",
        "import re\n\ndef extract_max(s):\n    numbers = re.findall('\\d+', s)\n    return max(map(int, numbers))",
        "get_key = lambda d: list(d.keys())",
        "def generate_matrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    num = 1\n    top, bottom, left, right = 0, n - 1, 0, n - 1\n    \n    while num <= n * n:\n        for i in range(left, right + 1):\n            matrix[top][i] = num\n            num += 1\n        top += 1\n        \n        for i in range(top, bottom + 1):\n            matrix[i][right] = num\n            num += 1\n        right -= 1\n        \n        for i in range(right, left - 1, -1):\n            matrix[bottom][i] = num\n            num += 1\n        bottom -= 1\n        \n        for i in range(bottom, top - 1, -1):\n            matrix[i][left] = num\n            num += 1\n        left += 1\n    \n    return matrix",
        "def slope(x1, y1, x2, y2): \n    return (y2 - y1) / (x2 - x1)",
        "def cube_Sum(n):  \n    sum = 0  \n    for i in range(1, 2*n, 2):  \n        sum += i**3  \n    return sum",
        "def sort_tuple(lst): \n    return sorted(lst, key=lambda x: x[0])",
        "def get_inv_count(arr, n): \n    inv_count = 0\n    for i in range(n): \n        for j in range(i + 1, n): \n            if arr[i] > arr[j]: \n                inv_count += 1\n    return inv_count",
        "def get_odd_occurence(arr, n): \n    result = 0\n    for i in range(n): \n        result ^= arr[i] \n    return result",
        "def nth_super_ugly_number(n, primes):\n    import heapq\n    if n == 1:\n        return 1\n    heap = [1]\n    seen = {1}\n    for _ in range(n - 1):\n        curr_ugly = heapq.heappop(heap)\n        for prime in primes:\n            new_ugly = curr_ugly * prime\n            if new_ugly not in seen:\n                seen.add(new_ugly)\n                heapq.heappush(heap, new_ugly)\n    return heapq.heappop(heap)",
        "def get_Number(n, k): \n    odd_count = (n + 1) // 2 \n    if k <= odd_count: \n        return 2 * k - 1 \n    else: \n        return 2 * (k - odd_count)",
        "def find_platform(arr, dep, n): \n    arr.sort() \n    dep.sort() \n    platform = 1\n    res = 1\n    i = 1\n    j = 0\n    while i < n and j < n: \n        if arr[i] <= dep[j]: \n            platform += 1\n            i += 1\n            res = max(res, platform) \n        else: \n            platform -= 1\n            j += 1\n    return res",
        "def lcopy(lst): \n    return list(lst)",
        "def area_trapezium(base1, base2, height):\n    return 0.5 * (base1 + base2) * height",
        "def Sum(n): \n    sum = 0\n    i = 2\n    while i * i <= n: \n        if n % i: \n            i += 1\n        else: \n            n //= i \n            if n % i: \n                sum += i \n    if n > 1: \n        sum += n \n    return sum",
        "def is_triangleexists(a, b, c): \n    return a + b + c == 180 and a > 0 and b > 0 and c > 0",
        "def remove_negs(lst):  \n    return [num for num in lst if num >= 0]",
        "def raw_heap(arr):  \n    import heapq  \n    heapq.heapify(arr)  \n    return list(arr)",
        "def check_Even_Parity(num): \n    count = 0\n    while num: \n        count += num & 1\n        num >>= 1\n    return count % 2 == 0",
        "def listify_list(colors):\n    return list(map(list, colors))",
        "def count_list(lst):\n    count = sum(1 for x in lst if isinstance(x, list))\n    return count ** 2",
        "anagram_lambda = lambda lst, s: [word for word in lst if sorted(word) == sorted(s)]",
        "def n_common_words(text, n):\n    words = text.split()\n    word_count = {}\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    sorted_word_count = sorted(word_count.items(), key=lambda x: x[1], reverse=True)\n    return sorted_word_count[:n]",
        "palindrome_lambda = lambda lst: list(filter(lambda s: s == s[::-1], lst))",
        "def ntimes_list(lst, n):\n    return list(map(lambda x: x * n, lst))",
        "def check_monthnumb(month):\n    if month == \"February\":\n        return False\n    else:\n        return True",
        "def remove_list_range(lst, lower, upper):  \n    return [sublist for sublist in lst if all(lower <= x <= upper for x in sublist)]",
        "sum_positivenum = lambda nums: sum(num for num in nums if num > 0)",
        "def are_Rotations(s1, s2):  \n    if len(s1)!= len(s2): \n        return False\n    temp = s1 + s1 \n    return temp.find(s2)!= -1",
        "def fibonacci(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)",
        "def check_Concat(s, t): \n    if s.count(t) * len(t) == len(s): \n        return True \n    else: \n        return False",
        "def lcm(a, b):  \n    def gcd(x, y):  \n        while(y):  \n            x, y = y, x % y  \n        return x  \n    return (a * b) // gcd(a, b)",
        "def sort_String(s): \n    return ''.join(sorted(s))",
        "def sum_even_odd(lst):\n    first_even = next((x for x in lst if x % 2 == 0), None)\n    first_odd = next((x for x in lst if x % 2!= 0), None)\n    return first_even + first_odd if first_even is not None and first_odd is not None else None",
        "div_of_nums = lambda nums, m, n: [num for num in nums if num % m == 0 and num % n == 0]",
        "def is_Isomorphic(s, t): \n    if len(s)!= len(t): \n        return False\n    \n    s_to_t = {} \n    t_to_s = {} \n    \n    for i in range(len(s)): \n        if s[i] in s_to_t: \n            if s_to_t[s[i]]!= t[i]: \n                return False\n        else: \n            s_to_t[s[i]] = t[i] \n            \n        if t[i] in t_to_s: \n            if t_to_s[t[i]]!= s[i]: \n                return False\n        else: \n            t_to_s[t[i]] = s[i] \n            \n    return True",
        "def sum_num(nums):\n    return sum(nums) / len(nums)",
        "def is_odd(n):  \n    return n & 1 == 1",
        "def reverse_list_lists(lst):  \n    return [sublist[::-1] for sublist in lst]",
        "def find_Extra(arr1, arr2, n): \n    for i in range(n): \n        if arr1[i]!= arr2[i]: \n            return i \n    return n",
        "def same_Length(num1, num2): \n    len1 = len(str(num1)) \n    len2 = len(str(num2)) \n    return len1 == len2 \n\nsame_Length(12, 1) == False",
        "def remove_spaces(s): \n    return s.replace(\"  \", \" \").replace(\"  \", \" \").replace(\"  \", \" \").replace(\"  \", \" \").replace(\"  \", \" \")",
        "def Extract(lst): \n    return [item[-1] for item in lst]",
        "def float_to_tuple(input_string):\n    return tuple(map(float, input_string.split(', ')))",
        "def max_sum_subseq(arr):\n    if not arr:\n        return 0\n    n = len(arr)\n    if n == 1:\n        return arr[0]\n    dp = [0] * n\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + arr[i])\n    return dp[-1]",
        "def sort_list_last(lst): \n    return sorted(lst, key=lambda x: x[-1])",
        "def is_Word_Present(sentence, word): \n    return word in sentence",
        "def match_num(s): \n    return s.startswith('5')",
        "def add_dict(d1, d2):\n    from collections import Counter\n    combined = Counter(d1) + Counter(d2)\n    return dict(combined)",
        "def count_Unset_Bits(n):  \n    count = 0  \n    for i in range(1, n + 1):  \n        count += bin(i).count('0') - 1  \n    return count",
        "def even_num(n):  \n    return n % 2 == 0",
        "import re\n\ndef extract_date(url):\n    pattern = r'/(\\d{4})/(\\d{2})/(\\d{2})/'\n    match = re.search(pattern, url)\n    if match:\n        return [match.groups()]\n    else:\n        return []",
        "def find_fixed_point(arr, n): \n    for i in range(n): \n        if arr[i] == i: \n            return i \n    return -1",
        "def previous_palindrome(n):\n    n -= 1\n    while not str(n) == str(n)[::-1]:\n        n -= 1\n    return n",
        "def maximum_product(nums):\n    import heapq\n    max_heap = [-num for num in nums]\n    heapq.heapify(max_heap)\n    num1 = -heapq.heappop(max_heap)\n    num2 = -heapq.heappop(max_heap)\n    num3 = -heapq.heappop(max_heap)\n    return num1 * num2 * num3",
        "def end_num(s): \n    return s.isdigit() or (s[-1].isdigit() and not s[-2].isdigit())",
        "def rearrange_numbs(arr): \n    return sorted(arr, key=lambda x: (x < 0, x))",
        "def multiply_list(lst):\n    result = 1\n    for num in lst:\n        result *= num\n    return result",
        "def chunk_tuples(tup, n):  \n    return [tup[i:i+n] for i in range(0, len(tup), n)]",
        "def super_seq(str1, str2, m, n): \n    dp = [[0] * (n + 1) for _ in range(m + 1)] \n  \n    for i in range(m + 1): \n        for j in range(n + 1): \n            if i == 0: \n                dp[i][j] = j \n            elif j == 0: \n                dp[i][j] = i \n            elif str1[i - 1] == str2[j - 1]: \n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else: \n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) \n  \n    return dp[m][n]",
        "def max_of_two(a, b):\n    if a > b:\n        return a\n    else:\n        return b",
        "def mutiple_tuple(tup): \n    product = 1\n    for num in tup: \n        product *= num \n    return product",
        "def change_date_format(date):  \n    year, month, day = date.split('-')  \n    return f'{day}-{month}-{year}'",
        "def count_tuplex(tuplex, item): \n    return tuplex.count(item)",
        "def sum_series(n):\n    total = 0\n    for i in range(1, n+1):\n        total += i**3\n    return total",
        "def remove_duplic_list(lst):\n    seen = set()\n    result = []\n    for word in lst:\n        if word not in seen:\n            seen.add(word)\n            result.append(word)\n    return result",
        "import re\n\ndef camel_to_snake(s):\n    return re.sub(r'([a-z0-9])([A-Z])', r'\\1_\\2', s).lower()",
        "def dealnnoy_num(m, n):\n    if m == 0 or n == 0:\n        return 1\n    return dealnnoy_num(m - 1, n) + dealnnoy_num(m, n - 1) + dealnnoy_num(m - 1, n - 1)",
        "def series_sum(n):\n    return sum(i**2 for i in range(1, n+1))",
        "def find_closet(arr1, arr2, arr3, n, m, k): \n    i, j, l = 0, 0, 0\n    result = []\n    min_diff = float('inf')\n    \n    while i < n and j < m and l < k: \n        min_val = min(arr1[i], arr2[j], arr3[l]) \n        max_val = max(arr1[i], arr2[j], arr3[l]) \n        if max_val - min_val < min_diff: \n            min_diff = max_val - min_val \n            result = [arr1[i], arr2[j], arr3[l]] \n        if arr1[i] == min_val: \n            i += 1\n        elif arr2[j] == min_val: \n            j += 1\n        else: \n            l += 1\n    \n    return tuple(result)",
        "def count_elim(lst):\n    count = 0\n    for element in lst:\n        if isinstance(element, tuple):\n            break\n        count += 1\n    return count",
        "def check_element(lst1, lst2): \n    for element in lst2: \n        if element in lst1: \n            return True \n    return False",
        "import heapq\n\ndef combine_lists(list1, list2):\n    return list(heapq.merge(list1, list2))",
        "def tuple_to_set(tup):  \n    return set(tup)",
        "def most_common_elem(text, n): \n    from collections import Counter \n    cnt = Counter(text) \n    common = cnt.most_common(n) \n    return common",
        "def len_log(words):\n    return min(len(word) for word in words)",
        "def get_item(tup, index):  \n    return tup[index]",
        "def max_similar_indices(list1, list2):\n    result = []\n    for t1, t2 in zip(list1, list2):\n        max_tuple = tuple(max(a, b) for a, b in zip(t1, t2))\n        result.append(max_tuple)\n    return result",
        "def profit_amount(selling_price, cost_price):\n    if selling_price > cost_price:\n        return selling_price - cost_price\n    else:\n        return None",
        "def is_abundant(n):\n    divisors = [i for i in range(1, n) if n % i == 0]\n    return sum(divisors) > n",
        "import re\n\ndef split_list(s):\n    return re.findall('[A-Z][^A-Z]*', s)",
        "def get_First_Set_Bit_Pos(n):  \n    position = 0  \n    while n > 0:  \n        position += 1  \n        if n & 1:  \n            return position  \n        n >>= 1  \n    return 0",
        "def int_to_roman(num): \n    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] \n    syb = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"] \n    roman_num = '' \n    i = 0\n    while num > 0: \n        for _ in range(num // val[i]): \n            roman_num += syb[i] \n            num -= val[i] \n        i += 1\n    return roman_num",
        "def Average(lst): \n    return sum(lst) / len(lst)",
        "def roman_to_int(s):\n    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n    for char in reversed(s):\n        current_value = roman_values[char]\n        if current_value < prev_value:\n            total -= current_value\n        else:\n            total += current_value\n        prev_value = current_value\n    return total",
        "def sum_Even(l, r): \n    total = 0\n    for i in range(l, r+1): \n        if i % 2 == 0: \n            total += i \n    return total",
        "def word_len(word): \n    return len(word) % 2 == 0",
        "def remove_empty(tuples_list):\n    return [t for t in tuples_list if t or not t and t!= ()]",
        "def join_tuples(lst): \n    from collections import defaultdict \n    \n    d = defaultdict(list) \n    \n    for key, value in lst: \n        d[key].append(value) \n    \n    result = [] \n    for key, values in d.items(): \n        result.append((key, *values)) \n    \n    return result",
        "def min_of_two(a, b): \n    if a < b: \n        return a \n    else: \n        return b",
        "concatenate_nested = lambda x, y: x + y",
        "def left_rotate(s, n): \n    return s[n:] + s[:n]",
        "def min_sum_path(triangle):\n    n = len(triangle)\n    for i in range(1, n):\n        for j in range(i+1):\n            if j == 0:\n                triangle[i][j] += triangle[i-1][j]\n            elif j == i:\n                triangle[i][j] += triangle[i-1][j-1]\n            else:\n                triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j])\n    return min(triangle[n-1])",
        "def count_element_freq(test_tup):  \n    freq_dict = {}  \n    for sub in test_tup:  \n        if isinstance(sub, tuple):  \n            for el in sub:  \n                if el in freq_dict:  \n                    freq_dict[el] += 1  \n                else:  \n                    freq_dict[el] = 1  \n        else:  \n            if sub in freq_dict:  \n                freq_dict[sub] += 1  \n            else:  \n                freq_dict[sub] = 1  \n    return freq_dict",
        "def sum_elements(tup): \n    return sum(tup)",
        "def modular_sum(arr, n, m): \n    mod_sum = [0] * m \n    mod_sum[0] = 1\n    prev_mod = [0] * m \n    for i in range(n): \n        for j in range(m-1, -1, -1): \n            prev_mod[j] = mod_sum[j] \n        for j in range(1, m): \n            mod_sum[j] = prev_mod[(j - arr[i] % m + m) % m] \n        mod_sum[arr[i] % m] = mod_sum[arr[i] % m] + 1\n    return mod_sum[m-1] > 1",
        "def radix_sort(arr):\n    RADIX = 10\n    placement = 1\n    max_digit = max(arr)\n    \n    while placement < max_digit:\n      buckets = [list() for _ in range(RADIX)]\n      for i in arr:\n        tmp = int((i / placement) % RADIX)\n        buckets[tmp].append(i)\n      a = 0\n      for b in range(RADIX):\n        buck = buckets[b]\n        for i in buck:\n          arr[a] = i\n          a += 1\n      placement *= RADIX\n    return arr",
        "def largest_pos(lst):\n    return max(lst, key=abs) if lst else None",
        "def sqrt_root(n): \n    return n ** 0.5",
        "def get_lcm(arr):\n    import math\n    lcm = arr[0]\n    for i in arr[1:]:\n        lcm = lcm * i // math.gcd(lcm, i)\n    return lcm",
        "def check_isosceles(a, b, c): \n    return a!= b and b!= c and a!= c",
        "def lbs(arr):\n    n = len(arr)\n    lis = [1]*n\n    lds = [1]*n\n    for i in range (1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i]< lis[j] + 1 :\n                lis[i] = lis[j]+1\n    for i in range (n-2, -1, -1):\n        for j in range(n-1, i, -1):\n            if arr[i] > arr[j] and lds[i] < lds[j] + 1 :\n                lds[i] = lds[j]+1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i]+lds[i]-1)\n    return maximum",
        "def max_sum_increasing_subsequence(arr, n):  \n    dp = [0] * n  \n    dp[0] = arr[0]  \n    for i in range(1, n):  \n        dp[i] = arr[i]  \n        for j in range(i):  \n            if arr[i] > arr[j]:  \n                dp[i] = max(dp[i], dp[j] + arr[i])  \n    return max(dp)",
        "def capitalize_first_last_letters(s):\n    return ''.join([word[0].upper() + word[1:-1] + word[-1].upper() if len(word) > 1 else word[0].upper() + word[-1].upper() for word in s.split(' ')])",
        "def get_pairs_count(arr, n, target): \n    count = 0\n    for i in range(n): \n        for j in range(i+1, n): \n            if arr[i] + arr[j] == target: \n                count += 1\n    return count",
        "def min_length(lst): \n    min_len = min(len(sub_lst) for sub_lst in lst) \n    min_lst = [sub_lst for sub_lst in lst if len(sub_lst) == min_len] \n    return min_len, min_lst[0]",
        "def min_coins(coins, count, amount):\n    if amount == 0:\n        return 0\n    if count == 0 and amount!= 0:\n        return float('inf')\n    if coins[count-1] > amount:\n        return min_coins(coins, count-1, amount)\n    return min(min_coins(coins, count-1, amount), 1 + min_coins(coins, count, amount - coins[count-1]))",
        "def check_permutation(s1, s2): \n    if len(s1)!= len(s2): \n        return False \n    else: \n        return sorted(s1) == sorted(s2)",
        "def remove_datatype(test_tup, K): \n    res = [ele for ele in test_tup if not isinstance(ele, K)] \n    return res",
        "def search_literal(literal, string):\n    index = string.find(literal)\n    if index!= -1:\n        return (index, index + len(literal))\n    else:\n        return (-1, -1)",
        "def nth_items(lst, n):\n    return [lst[i] for i in range(0, len(lst), n)]",
        "basesnum_coresspondingnum = lambda bases, nums: list(map(lambda x, y: x ** y, bases, nums))",
        "def check_abundant(n):\n    if n < 1:\n        return False\n    divisors_sum = 1  # 1 is always a divisor\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i!= n // i:\n                divisors_sum += n // i\n    return divisors_sum > n",
        "def toggle_F_and_L_bits(n): \n    first_bit = 1 << (n.bit_length() - 1) \n    last_bit = 1 \n    return n ^ (first_bit | last_bit)",
        "def longest_increasing_subsequence(arr):\n    n = len(arr)\n    lis = [1] * n\n    for i in range (1, n):\n        for j in range(0, i):\n            if arr[i] > arr[j] and lis[i]< lis[j] + 1 :\n                lis[i] = lis[j]+1\n    maximum = 0\n    for i in range(n):\n        maximum = max(maximum, lis[i])\n    return maximum",
        "def odd_Num_Sum(n):  \n    sum = 0  \n    for i in range(1, 2*n, 2):  \n        sum += i**5  \n    return sum",
        "def extract_column(matrix, col_index):  \n    return [row[col_index] for row in matrix]",
        "def Split(lst): \n    return [x for x in lst if x % 2!= 0]",
        "def difference(n):\n    sum_of_cubes = sum([i**3 for i in range(1, n+1)])\n    sum_of_numbers = sum(range(1, n+1))\n    return sum_of_cubes - sum_of_numbers",
        "def find_Odd_Pair(arr, n):    \n    odd_count = 0\n    for i in range(n):        \n        for j in range(i+1, n):            \n            if (arr[i] ^ arr[j]) % 2!= 0:                \n                odd_count += 1\n    return odd_count",
        "def toggle_string(s):  \n    return s.swapcase()",
        "def digit_distance_nums(num1, num2): \n    num1_str = str(num1) \n    num2_str = str(num2) \n    max_len = max(len(num1_str), len(num2_str)) \n    distance = 0 \n    for i in range(max_len): \n        digit1 = int(num1_str[i]) if i < len(num1_str) else 0 \n        digit2 = int(num2_str[i]) if i < len(num2_str) else 0 \n        distance += abs(digit1 - digit2) \n    return distance",
        "def max_sub_array_sum(arr, n): \n    max_so_far = arr[0] \n    curr_max = arr[0] \n  \n    for i in range(1,n): \n        curr_max = max(arr[i], curr_max + arr[i]) \n        max_so_far = max(max_so_far, curr_max) \n      \n    return max_so_far",
        "def union_elements(t1, t2):\n    return tuple(set(t1) | set(t2))",
        "def Find_Max_Length(lst): \n    max_length = 0\n    for sublist in lst: \n        if len(sublist) > max_length: \n            max_length = len(sublist) \n    return max_length",
        "def count_Pairs(arr, n):  \n    count = 0\n    for i in range(n): \n        for j in range(i+1, n): \n            if arr[i]!= arr[j]: \n                count += 1\n    return count",
        "split = lambda s: [c for c in s]",
        "def sum_digits(n):\n    return sum(int(digit) for digit in str(n))",
        "def issort_list(lst):\n    return lst == sorted(lst)",
        "def empty_list(n):  \n    return [{} for _ in range(n)]",
        "def sort_sublists(lst): \n    return [sorted(sublist) for sublist in lst]",
        "def two_unique_nums(arr):\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    \n    result = []\n    for num, count in freq.items():\n        if count == 1:\n            result.append(num)\n    \n    return result",
        "def unique_product(lst):\n    unique_nums = set(lst)\n    product = 1\n    for num in unique_nums:\n        product *= num\n    return product",
        "def is_Sub_Array(arr1, arr2, n, m): \n    if m > n: \n        return False\n    for i in range(n - m + 1): \n        flag = True\n        for j in range(m): \n            if arr1[i + j]!= arr2[j]: \n                flag = False\n                break\n        if flag: \n            return True\n    return False",
        "def last_Digit_Factorial(n):  \n    if n == 0 or n == 1: \n        return 1\n    last_digit = 1\n    for i in range(2, n + 1): \n        last_digit = (last_digit * i) % 10\n    return last_digit",
        "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result",
        "def extract_even(t):\n    result = ()\n    for i in t:\n        if isinstance(i, tuple):\n            result += (extract_even(i),)\n        elif i % 2 == 0:\n            result += (i,)\n    return result",
        "def surface_Area(base_edge, slant_height): \n    base_area = base_edge ** 2\n    lateral_area = 2 * base_edge * slant_height\n    surface_area = base_area + lateral_area\n    return surface_area",
        "def my_dict(d): \n    return len(d) == 0",
        "def catalan_number(n):\n    if n == 0:\n        return 1\n    catalan = [0] * (n + 1)\n    catalan[0] = 1\n    catalan[1] = 1\n    for i in range(2, n + 1):\n        catalan[i] = 0\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[n]",
        "import re\n\ndef find_adverbs(sentence):\n    adverbs = re.findall(r'\\b\\w+ly\\b', sentence)\n    result = []\n    for adverb in adverbs:\n        start = sentence.find(adverb)\n        result.append(f'{start}-{start + len(adverb)}: {adverb}')\n    return''.join(result)",
        "def expensive_items(items, n):\n    import heapq\n    expensive = heapq.nlargest(n, items, key=lambda x: x['price'])\n    return expensive",
        "def split_Arr(arr, n, k): \n    part1 = arr[:k] \n    part2 = arr[k:] \n    return part2 + part1",
        "def list_tuple(lst): return tuple(lst)",
        "def big_diff(arr):\n    return max(arr) - min(arr)",
        "def swap_List(newList): \n    newFirst = newList[0]  \n    newLast = newList[-1] \n    if len(newList) > 1: \n        newList[0] = newLast \n        newList[-1] = newFirst \n    return newList",
        "def removezero_ip(ip):\n    return '.'.join([str(int(part)) for part in ip.split('.')])",
        "def diff_even_odd(lst):\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0:\n            if first_even is None:\n                first_even = num\n            if first_odd is not None:\n                break\n        else:\n            if first_odd is None:\n                first_odd = num\n            if first_even is not None:\n                break\n    \n    return first_even - first_odd",
        "def find_kth(arr1, arr2, m, n, k): \n    if m > n: \n        return find_kth(arr2, arr1, n, m, k) \n    if m == 0: \n        return arr2[k-1] \n    if k == 1: \n        return min(arr1[0], arr2[0]) \n    i = min(m, k // 2) \n    j = k - i \n    if arr1[i-1] < arr2[j-1]: \n        return find_kth(arr1[i:m], arr2, m-i, n, k-i) \n    elif arr1[i-1] > arr2[j-1]: \n        return find_kth(arr1, arr2[j:n], m, n-j, k-j) \n    else: \n        return arr1[i-1]",
        "def armstrong_number(num):\n    order = len(str(num))\n    sum = 0\n    temp = num\n    while temp > 0:\n        digit = temp % 10\n        sum += digit ** order\n        temp //= 10\n    return num == sum",
        "def sum_average(n):\n    sum_n = sum(range(1, n+1))\n    avg_n = sum_n / n\n    return sum_n, avg_n",
        "def is_Even(n): \n    return (n & 1) == 0",
        "def similar_elements(t1, t2):\n    return tuple(set(t1) & set(t2))",
        "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False",
        "def heap_queue_largest(lst, n): \n    import heapq \n    largest = heapq.nlargest(n, lst) \n    return largest",
        "import re\n\ndef find_char_long(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)",
        "square_nums = lambda nums: list(map(lambda x: x**2, nums))",
        "def small_nnum(lst, n):\n    return sorted(lst)[:n]"
    ],
    "correct_index": [
        4,
        5,
        6,
        7,
        10,
        12,
        13,
        14,
        15,
        17,
        20,
        22,
        23,
        24,
        26,
        27,
        28,
        29,
        31,
        33,
        34,
        35,
        38,
        40,
        41,
        43,
        44,
        45,
        46,
        47,
        48,
        50,
        52,
        53,
        54,
        55,
        56,
        57,
        61,
        63,
        64,
        65,
        66,
        67,
        68,
        71,
        72,
        74,
        75,
        77,
        78,
        79,
        80,
        81,
        82,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        94,
        95,
        96,
        97,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        109,
        110,
        112,
        114,
        115,
        117,
        118,
        119,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        131,
        132,
        133,
        135,
        136,
        137,
        139,
        140,
        143,
        144,
        146,
        147,
        149,
        152,
        155,
        156,
        157,
        159,
        161,
        163,
        165,
        167,
        169,
        170,
        173,
        174,
        177,
        178,
        180,
        181,
        184,
        185,
        186,
        187,
        188,
        189,
        190,
        191,
        192,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        210,
        211,
        212,
        213,
        215,
        216,
        217,
        218,
        220,
        221,
        222,
        223,
        224,
        226,
        227,
        228,
        230,
        231,
        232,
        233,
        234,
        236,
        238,
        240,
        241,
        242,
        243,
        245,
        246,
        247,
        248,
        249,
        251,
        253,
        254,
        256,
        257,
        260,
        261,
        263,
        264,
        265,
        268,
        269,
        270,
        272,
        273,
        275,
        276,
        280,
        282,
        284,
        285,
        286,
        288,
        289,
        290,
        291,
        292,
        293,
        294,
        295,
        296,
        299,
        301,
        302,
        303,
        305,
        307,
        308,
        310,
        312,
        314,
        318,
        320,
        322,
        323,
        324,
        327,
        328,
        330,
        331,
        332,
        333,
        334,
        337,
        340,
        341,
        342,
        344,
        345,
        346,
        347,
        350,
        353,
        354,
        355,
        356,
        357,
        358,
        360,
        361,
        363,
        365,
        368,
        369,
        371,
        372,
        373,
        375,
        377,
        378,
        379,
        380,
        381,
        383,
        384,
        385,
        387,
        389,
        390,
        391,
        394,
        395,
        396,
        397,
        399,
        402,
        404,
        408,
        411,
        412,
        414,
        417,
        418,
        419,
        420,
        421,
        422,
        423,
        425,
        427,
        428,
        429,
        430,
        431,
        432,
        435,
        436,
        439,
        440,
        441,
        443,
        444,
        445,
        446,
        447,
        448,
        449,
        450,
        451,
        454,
        456,
        457,
        460,
        461,
        462,
        463,
        465,
        466,
        467,
        470,
        471,
        473
    ]
}